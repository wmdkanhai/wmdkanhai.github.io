[{"title":"设计模式之单例模式","date":"2017-05-17T00:49:19.000Z","path":"2017/05/17/设计模式之单例模式/","text":"设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件人员所采用。 总之设计模式给我的印象是很难懂的，但是在后来的实际开发中不断的使用到了设计模式，在面试的过程中也有被问到，所以总结整理下。 1、什么是单例模式单例模式（Single Pattern）属于是创建型模式，提供了一种创建对象的最佳方式。 1、特点： 单例类只能有一个实例 单例类必须自己创建自己的唯一实例 单例类必须给所有其他对象提供这一实例 2、使用场景单例模式确保某个类只有一个实例，而且自己在类的内部实现实例化并向整个系统提供这个实例。 1、要创建的对象需要消耗的资源过多（I/O操作，数据库的连接等）。 2、小光开店中 日报表格只有一份—单例模式这个例子更加生动形象。 3、在 Android 开发中 Application 的创建。内容来自这里 Application和Activity,Service一样是Android框架的一个系统组件，当Android程序启动时系统会创建一个Application对象且只创建一个，用来存储系统的一些信息，所以Application是单例（singleton）模式的一个类。 2、如何使用单例模式1、饿汉式它基于 classloder 机制避免了多线程的问题，所以就线程安全，但是实例在类加载的时候就实例化，浪费内存。 代码示例： /** * 这种实现是饿汉式 * instance 在类加载的时候就实例化，容易产生垃圾对象 */ public class Singleton { //创建 Singleton 的一个对象 private static Singleton instance = new Singleton(); //让构造函数为 private，这样该类就不能被实例化了 private Singleton() { } //获取唯一可用的对象 public static Singleton getInstance(){ return instance; } public void showMessage(){ System.out.println(&quot;hello world ,Singleton Pattern&quot;); } } 其他类调用： public class Client { public static void main(String[] args) { //获取唯一一个可用对象 Singleton instance = Singleton.getInstance(); //调用这个对象的方法 instance.showMessage(); } } 2、懒汉式这种方式是最基本的实现方式，是 Lazy 初始化（懒加载），但是实现最大的问题就是不支持多线程，但是可以通过 synchronized 加锁，达到线程安全。 public class Singleton2 { //先不创建实例，在第一调用getInstance() 时实例化自己 private static Singleton2 instance; private Singleton2() { } public static synchronized Singleton2 getInstance(){ if(instance == null){ instance = new Singleton2(); } return instance; } } 这里使用 synchronized 关键字来锁住 getInstance()，也就是说 getInstance() 方法只能运行在一个线程中，也就是这段代码已经在一个线程中运行，另外一个线程要想运行这块代码就会被阻塞而一直等待。 每次访问都要进行线程同步（调用 synchronized 锁），实际在第一次调用该方法的时候才需要同步，一旦这个实例创建后同步就完全没有必要，所以这种每次都需要同步的方法显然会造成不必要的同步开销。 3、双检锁/双重校验锁（DCL，即 double-checked locking）为了解决上面提到的 每次访问都要进行线程同步 的问题，那加一个条件把它限制在 只在第一调用的时候同步。也就是我们先判断是否创建了实例，实例要是没有存在就进入 进行线程同步，然后创建实例，如果实例已经创建，就直接return。 public class Singleton3 { private volatile static Singleton3 instance = null; private Singleton3(){} public static Singleton3 getIntence(){ if (instance == null) {//先检查实例是否存在 synchronized (Singleton3.class) {//同步代码块，线程安全的创建实例 if (instance == null) {//再次检查，实例不存在就创建实例 instance = new Singleton3(); } } } return instance; } } 这里的 volatile 关键字，作用就是避免 DCL 失效， volatile变量的读操作的性能消耗与普通变量没什么区别；但是写操作可能会变的慢一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。 4、静态内部类 这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。 public class Singleton4 { private Singleton4(){} //静态内部类，该类的实例与外部类的实例没有绑定关系，而且只有被调用的时候 //才会装载，从而实现了延迟加载 private static class SingletonHolder{ //静态初始化器，由JVM来保证线程安全 private static Singleton4 instance = new Singleton4(); } public static Singleton4 getInstance(){ return SingletonHolder.instance; } } 当getInstance()方法第一次被调用的时候，它第一次读取SingletonHolder.instance，导致SingletonHolder类得到初始化；而这个类在装载并被初始化的时候，会初始化它的静态域，从而创建Singleton的实例，由于是静态的域，因此只会在虚拟机装载类的时候初始化一次，并由虚拟机来保证它的线程安全性。 5、枚举 这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。 3、哪些源码中使用到了单例模式","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://wmding.com/tags/设计模式/"}]},{"title":"AndroidStudio快捷键和插件","date":"2017-05-16T15:51:23.000Z","path":"2017/05/16/AndroidStudio快捷键和插件/","text":"在使用 Android Studio 的过程中，不免使用快捷键来提高逼格，此外还有许多插件帮助我们快速的开发。所以这里做出总结。 1、Android Studio中的常用快捷键1、全局搜索按两次 Shift 2、查找Ctrl + F 3、查找下一处F3 4、查找上一处Shift + F3 5、替换Ctrl + R 6、查找 ClassCtrl + N 7、查找文件Ctrl + Shift + N 8、全局搜索（在文件路径中查找）Ctrl + Shift + F 9、打开文件切换Alt + Right/Left 10、调到源码F4 11、跳转到某行Ctrl + G 12、打开类型层级（查看继承关系）Ctrl + H 13、查看方法层级Ctrl + Shift + H 14、方法调用层级Ctrl + Alt + H （光标放在方法上） 15、重写方法Ctrl + O （Override） 16、实现方法Ctrl + I （实现接口中的方法） 17、快速生成代码块Ctrl + Alt + T 18、提取方法Ctrl + Alt + M 19、大小写切换Ctrl+Shift+U 2、好用的插件1、通过 Wifi 调试手机ADB WiFi 2、ButterKnife 注解生成器：ButterKnife Zelezny 3、把 json 快速转换成 JavaBeanGsonFormat 未完待续，欢迎拍砖。","tags":[{"name":"Android快捷键","slug":"Android快捷键","permalink":"http://wmding.com/tags/Android快捷键/"}]},{"title":"Android 学习笔记目录","date":"2017-05-15T15:49:11.000Z","path":"2017/05/15/Android学习笔记目录/","text":"一直在学习 Android ，但是在使用的时候总是有点不熟悉，趁着毕业前的这段时间，以《Android 开发艺术探索》和《第一行代码（第二版）》为辅助学习的资料，对 Android 的知识进行学习。 在整理的过程中不免会参考和引用别人的文章，我会注明出处，如有问题请联系我，我定会及时改正。 首先对自己认为重要的知识进行挑选 1、Android Studio 快捷键的整理以及好用插件的使用 2、项目构建 Gradle 的学习 3、Activity 的学习 3.1 Activity 的生命周期和启动模式 3.2 Activity 中使用 Menu 3.3 Activity 中 Intent 的使用，特别是 Intent 传递对象 3.4 Activity 的最佳实践（主要包括随时随地退出程序和在实际项目中的写法） 4、View 的学习 4.1 View 的事件体系，滑动冲突的解决 4.2 View 的工作原理 4.3 自定义 View 的分类以及实现方式 5 Fragment 的使用 6 Android 中的数据持久化 6.1 文件存储 6.2 SharedPreferences 存储 6.3 SQLite 数据库存储和操作数据库的一些第三方库 7 网络技术 7.1 主流网络框架的学习 7.2 json 数据的解析 7.3 webView 的使用 8 多媒体 8.1 通知的使用以及底层实现 (RemoteViews) 8.2 拍照，录音，视频 9 Android 动画（view 动画和属性动画） 10 Window 和 WindowManager 11 Material Design 的学习","tags":[{"name":"Android","slug":"Android","permalink":"http://wmding.com/tags/Android/"}]},{"title":"Glide的基本使用","date":"2017-03-21T00:49:19.000Z","path":"2017/03/21/Glide的基本使用/","text":"现在比较流行、好用的图片加载的框架应该是 Clide 和 Picasso 了。大多数情况下加载图片都是一行代码就能搞定，在平时的项目中也基本就是用用，没有深入的了解。今天看到郭霖大神的微信公共号推送的文章是 《开始新的系列，Glide 的基本使用》，看来郭神是要开始研究 Glide 了。随便拿文章来学习，记录一下，方便以后的使用。 1、开始Glide 是一款由 Bump Technologies 开发的图片加载框架，使得我们可以在 Android 平台上以极度简单的方式加载和展示图片。 Github 上的地址： https://github.com/bumptech/glide 添加依赖： compile &apos;com.github.bumptech.glide:glide:3.7.0&apos; 添加网络权限 &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt; 2、加载图片String url = &quot;http://cn.bing.com/az/hprichbg/rb/Dongdaemun_ZH-CN10736487148_1920x1080.jpg&quot;; //加载图片 Glide.with(this).load(url).into(mImageView); 1、Glide.with() 方法用于创建一个加载图片的实例。with() 方法中可以接收 Context、Activity、Fragment 类型的参数，即不管在 Activity 还是在 Fragment 中调用 with()方法，都可以直接传入 this。要是不在 Activity 中也不在 Fragment 中的话，我们可以获取当前程序的 ApplicationContext 。 注意： with() 中传入的实例会决定 Glide 加载图片的生命周期。 传入的是 Activity 或者 Fragment 的实例，当这个 Activity 或 Fragment 被销毁的收，图片也会停止加载。 传入的是 ApplicationContext ，只有当应用程序被杀掉的时候，图片加载才会停止。 2、load() 方法用于指定加载的图片资源Glide 支持加载各种各样的图片资源，包括网络图片、本地图片、应用资源、二进制流、Uri 对象等等。所以 load() 方法有很多个方法的重载： //加载本地图片 File file = getImagePath(); Glide.with(this).load(file).into(mImageView); // 加载应用资源 int resource = R.drawable.image; Glide.with(this).load(resource).into(imageView); // 加载二进制流 byte[] image = getImageBytes(); Glide.with(this).load(image).into(imageView); // 加载 Uri 对象 Uri imageUri = getImageUri(); Glide.with(this).load(imageUri).into(imageView); 根据自己的情况进行选择 3、into() 方法into() 就是图片在那个 ImageView 上显示。 3、占位图加载图片的时候我们需要等待，这个时间里我们希望优化用户的体验，添加占位图 Glide.with(this) .load(url) .placeholder(R.mipmap.ic_launcher)//添加占位图 .diskCacheStrategy(DiskCacheStrategy.NONE)//禁用 Glide的缓存 .into(mImageView); 由于我们已经加载过图片，所以在测试的时候就没有等到占位图显示出来，我们要加载的图片就已经显示了，这是因为 Glide 有缓存功能，我们把缓存功能去掉，点击加载图片后就可以看到占位图，然后再看到加载的图片了。 4、设置错误图片在加载过程中出错的话，加载出异常占位图，添加 error() Glide.with(this) .load(url) .placeholder(R.mipmap.ic_launcher)//添加占位图 .error(R.drawable.ic_error)//异常占位图 .diskCacheStrategy(DiskCacheStrategy.NONE)//禁用 Glide的缓存 .into(mImageView); 5、设置动画1）、使用 crossFade 来进行设置动画 Glide 默认是包含淡入淡出动画的，时间为 300 ms，我们也可以修改这个时间 Glide.with(this) .load(url) .placeholder(R.mipmap.ic_launcher)//添加占位图 .error(R.drawable.ic_error)//异常占位图 .crossFade(5000)//设置动画时间 .into(mImageView); 2）、使用 dontAnimate 取消动画 Glide.with(this) .load(url) .placeholder(R.mipmap.ic_launcher)//添加占位图 .error(R.drawable.ic_error)//异常占位图 .dontAnimate()//设置取消动画 .into(mImageView); 6、设置加载 Gif在使用 Picasso 是不支持 gif 加载的。但是 Glide 是支持的。 1）、简单的加载 简单的加载 gif 图片和普通图片是一致的。 Glide.with(this) .load(mGifurl)//加载 gif .placeholder(R.mipmap.ic_launcher)//添加占位图 .error(R.drawable.ic_error)//异常占位图 .into(mImageView); 2）、把 gif 图片当作普通图片加载 也就是加载 gif 图片的第一帧，和普通图片一样显示 Glide.with(this) .load(mGifurl)//加载 gif .asBitmap() .placeholder(R.mipmap.ic_launcher)//添加占位图 .error(R.drawable.ic_error)//异常占位图 .into(mImageView); 3）、检查是否是 gif 图片 就是在加载图片的时候判断是否是 gif 图片，如果是就加载，不是就不加载。 Glide.with(this) .load(mGifurl)//加载 gif .asGif()//判断是否是 gif .placeholder(R.mipmap.ic_launcher)//添加占位图 .error(R.drawable.ic_error)//异常占位图 .into(mImageView); 4）、加载本地视频缩略图 这里加载的是本地视频的第一帧，即视频的缩略图 File mVideoFile = new File(Environment.getExternalStorageDirectory(), &quot;xiaoming.mp4&quot;); Glide.with(this) .load(mVideoFile) .placeholder(R.mipmap.ic_launcher)//添加占位图 .error(R.drawable.ic_error)//异常占位图 .into(mImageView);","tags":[{"name":"Android","slug":"Android","permalink":"http://wmding.com/tags/Android/"}]},{"title":"网络请求（二）","date":"2017-03-20T08:15:32.000Z","path":"2017/03/20/网络请求（二）/","text":"retrofit 已经早就听说了，一直没有学习，为了使自己成为一个有理想、有抱负的程序猿，我决定学习下。 本文的学习记录参考 简书上的一篇文章 地址： http://www.jianshu.com/p/19ea72fba61a 1、初识Retrofit 是一个基于 OKHttp 的 Restful API 请求工具。将网络请求变成方法的调用，使用起来非常简洁方便。 官方介绍： http://square.github.io/retrofit/ Retrofit 会将你的 HTTP API 转换为 Java 中 interface 的形式。 通过 new Retrofit.Buidler()….build() 进行 Retrofit 的构建，即使用的是 Builder 模式。 &gt; Builder模式用于将一个复杂的对象的构建和它的表示分离，使得同样的构建过程可以创建不同的表示。这里Retrofit使用Builder模式支持了支持不同的转换（就是将HTTP返回的数据解析成Java对象，主要有Xml、Gson等）和返回（主要作用就是将Call对象转换成另一个对象，比如RxJava）。这里也就真正的达到了构建复杂对象和它的部件进行解耦。 使用 create() 方法创建网络请求接口类 GitHubService 的实例，然后在使用该实例的 listRepos() 方法获取到数据。 2、简单使用1、添加网络权限、添加依赖&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; 依赖： compile &apos;com.squareup.retrofit2:retrofit:2.2.0&apos; //如果用到gson解析 需要添加下面的依赖 compile &apos;com.squareup.retrofit2:converter-gson:2.2.0&apos; 2、创建返回数据的实体类 ResponseBean这里的数据是获取微信精选分类，接口是： http://apicloud.mob.com/wx/article/category/query?key=1228b5a794dc8 数据结构如下： 这里创建实体类的时候直接使用 Android studio 的插件 GsonFormat。 public class ResponseBean { /** * msg : success * result : [{&quot;cid&quot;:&quot;1&quot;,&quot;name&quot;:&quot;时尚&quot;},{&quot;cid&quot;:&quot;2&quot;,&quot;name&quot;:&quot;热点&quot;},{&quot;cid&quot;:&quot;3&quot;,&quot;name&quot;:&quot;健康&quot;},{&quot;cid&quot;:&quot;5&quot;,&quot;name&quot;:&quot;百科&quot;},{&quot;cid&quot;:&quot;7&quot;,&quot;name&quot;:&quot;娱乐&quot;},{&quot;cid&quot;:&quot;8&quot;,&quot;name&quot;:&quot;美文&quot;},{&quot;cid&quot;:&quot;9&quot;,&quot;name&quot;:&quot;旅行&quot;},{&quot;cid&quot;:&quot;10&quot;,&quot;name&quot;:&quot;媒体达人&quot;},{&quot;cid&quot;:&quot;11&quot;,&quot;name&quot;:&quot;搞笑&quot;},{&quot;cid&quot;:&quot;12&quot;,&quot;name&quot;:&quot;影视音乐&quot;},{&quot;cid&quot;:&quot;13&quot;,&quot;name&quot;:&quot;互联网&quot;},{&quot;cid&quot;:&quot;14&quot;,&quot;name&quot;:&quot;文史&quot;},{&quot;cid&quot;:&quot;15&quot;,&quot;name&quot;:&quot;金融&quot;},{&quot;cid&quot;:&quot;16&quot;,&quot;name&quot;:&quot;体育&quot;},{&quot;cid&quot;:&quot;17&quot;,&quot;name&quot;:&quot;游戏&quot;},{&quot;cid&quot;:&quot;18&quot;,&quot;name&quot;:&quot;两性&quot;},{&quot;cid&quot;:&quot;19&quot;,&quot;name&quot;:&quot;社交交友&quot;},{&quot;cid&quot;:&quot;20&quot;,&quot;name&quot;:&quot;女人&quot;},{&quot;cid&quot;:&quot;23&quot;,&quot;name&quot;:&quot;购物&quot;},{&quot;cid&quot;:&quot;24&quot;,&quot;name&quot;:&quot;美女&quot;},{&quot;cid&quot;:&quot;25&quot;,&quot;name&quot;:&quot;微信技巧&quot;},{&quot;cid&quot;:&quot;26&quot;,&quot;name&quot;:&quot;星座&quot;},{&quot;cid&quot;:&quot;27&quot;,&quot;name&quot;:&quot;美食&quot;},{&quot;cid&quot;:&quot;28&quot;,&quot;name&quot;:&quot;教育&quot;},{&quot;cid&quot;:&quot;29&quot;,&quot;name&quot;:&quot;职场&quot;},{&quot;cid&quot;:&quot;30&quot;,&quot;name&quot;:&quot;酷品&quot;},{&quot;cid&quot;:&quot;31&quot;,&quot;name&quot;:&quot;母婴&quot;},{&quot;cid&quot;:&quot;32&quot;,&quot;name&quot;:&quot;摄影&quot;},{&quot;cid&quot;:&quot;33&quot;,&quot;name&quot;:&quot;创投&quot;},{&quot;cid&quot;:&quot;34&quot;,&quot;name&quot;:&quot;典藏&quot;},{&quot;cid&quot;:&quot;35&quot;,&quot;name&quot;:&quot;家装&quot;},{&quot;cid&quot;:&quot;36&quot;,&quot;name&quot;:&quot;汽车&quot;},{&quot;cid&quot;:&quot;37&quot;,&quot;name&quot;:&quot;段子&quot;}] * retCode : 200 */ private String msg; private String retCode; private List&lt;ResultBean&gt; result; public String getMsg() { return msg; } public void setMsg(String msg) { this.msg = msg; } public String getRetCode() { return retCode; } public void setRetCode(String retCode) { this.retCode = retCode; } public List&lt;ResultBean&gt; getResult() { return result; } public void setResult(List&lt;ResultBean&gt; result) { this.result = result; } public static class ResultBean { /** * cid : 1 * name : 时尚 */ private String cid; private String name; public String getCid() { return cid; } public void setCid(String cid) { this.cid = cid; } public String getName() { return name; } public void setName(String name) { this.name = name; } } } 3、把 HTTP API 封装成 interfacepublic interface HttpService { //http://apicloud.mob.com/wx/article/category/query?key=1228b5a794dc8 @GET(&quot;category/{name}&quot;) Call&lt;ResponseBean&gt; getWxData(@Path(&quot;name&quot;) String name, @Query(&quot;key&quot;) String key); } 4、在 MainActivity 中private void initData() { String baseUrl = &quot;http://apicloud.mob.com/wx/article/&quot;; Retrofit retrofit = new Retrofit.Builder() .baseUrl(baseUrl) //返回的数据使用Gson解析 .addConverterFactory(GsonConverterFactory.create()) .build(); HttpService httpService = retrofit.create(HttpService.class); Call &lt;ResponseBean&gt; query = httpService.getWxData(&quot;query&quot;, &quot;1228b5a794dc8&quot;); query.enqueue(new Callback&lt;ResponseBean&gt;() { @Override public void onResponse(Call&lt;ResponseBean&gt; call, Response&lt;ResponseBean&gt; response) { List&lt;ResponseBean.ResultBean&gt; resultBeanList = response.body().getResult(); if (resultBeanList != null){ for (ResponseBean.ResultBean result:resultBeanList) { Log.e(&quot;resultBean&quot;, &quot;onResponse: &quot;+result.getCid()+&quot;-&quot;+result.getName() ); } } } @Override public void onFailure(Call&lt;ResponseBean&gt; call, Throwable t) { } }); 运行获取到数据。 3、和 RxJava 的简单结合使用1、添加依赖compile &apos;io.reactivex:rxandroid:1.2.1&apos; compile &apos;io.reactivex:rxjava:1.1.6&apos; compile &apos;com.google.code.gson:gson:2.8.0&apos; compile &apos;com.squareup.retrofit2:retrofit:2.2.0&apos; //如果用到gson解析 需要添加下面的依赖 compile &apos;com.squareup.retrofit2:converter-gson:2.2.0&apos; //Retrofit使用RxJava需要的依赖 compile &apos;com.squareup.retrofit2:adapter-rxjava:2.1.0&apos; 2、修改接口文件public interface HttpService { //http://apicloud.mob.com/wx/article/category/query?key=1228b5a794dc8 @GET(&quot;category/{name}&quot;) //Call&lt;ResponseBean&gt; getWxData(@Path(&quot;name&quot;) String name, @Query(&quot;key&quot;) String key); Observable&lt;ResponseBean&gt; getWxData(@Path(&quot;name&quot;) String name,@Query(&quot;key&quot;) String key); } 3、在 MainActivity 中private void initData() { String baseUrl = &quot;http://apicloud.mob.com/wx/article/&quot;; Retrofit retrofit = new Retrofit.Builder() .baseUrl(baseUrl) //返回的数据使用Gson解析 .addConverterFactory(GsonConverterFactory.create()) //使用RxJava模式 .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) .build(); HttpService httpService = retrofit.create(HttpService.class); Observable&lt;ResponseBean&gt; query = httpService.getWxData(&quot;query&quot;, &quot;1228b5a794dc8&quot;); query.subscribeOn(Schedulers.io())//设置网络请求在子线程中 .observeOn(AndroidSchedulers.mainThread())//回调在主线程中 .subscribe(new Action1&lt;ResponseBean&gt;() { @Override public void call(ResponseBean responseBean) { //请求成功 List&lt;ResponseBean.ResultBean&gt; resultBeanList = responseBean.getResult(); if (resultBeanList != null) { for (ResponseBean.ResultBean result : resultBeanList) { Log.e(&quot;resultBean&quot;, &quot;onResponse: &quot; + result.getCid() + &quot;-&quot; + result.getName()); } } } }, new Action1&lt;Throwable&gt;() { @Override public void call(Throwable throwable) { //请求失败 } }); } 同样获取到数据。","tags":[{"name":"Android retrofit","slug":"Android-retrofit","permalink":"http://wmding.com/tags/Android-retrofit/"}]},{"title":"给博客添加评论功能","date":"2017-03-20T06:07:32.000Z","path":"2017/03/20/博客添加评论功能/","text":"之前使用的是 TKL 的主题，今天在查看 hexo 地址： https://hexo.io/themes/ 的主题的时候，发现了好多好看的主题，折腾的心又开始在跳动，所以就把博客的主题修改成了 yilia 的。 随便把博客的评论功能添加上去。 1、更换主题1、clone 主题文件到 themes 目录下 git clone https://github.com/litten/hexo-theme-yilia.git yilia 2、在 hexo 根目录中的 _config.yml 文件中进行配置，对主题进行更改 theme: yilia 3、在主题文件中的 _config.yml 中进行配置页面 （PS：注意这个目录） 打开这个文件进行设置，作者已经在设置中添加了注释，所以都可以看明白。 4、需要注意的地方 #你的头像url avatar: /image/icon.jpg 这个地址是相对于博客存放的 github 的地址 2、添加评论功能这里我看大家使用的都是 多说 1、申请添加站点 2、在 hexo 根目录中的 _config.yml 文件中进行配置 # 配置多说评论，wmding是我在多说中添加的站点的名称 duoshuo_shortname: wmding 3、在主题文件中的 _config.yml 中进行配置 duoshuo: true","tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://wmding.com/tags/博客搭建/"}]},{"title":"网络请求（一）","date":"2017-03-18T06:13:32.000Z","path":"2017/03/18/网络请求（一）/","text":"在自己写 Demo 的时候，总是想追求完美，想使用一个自己顺手的网络请求框架，但是又不知道从哪里下手，自己真是 too young,too simple。 今天在翻看 stormzhang 的博客的时候，看到了这篇文章《Android开源项目推荐之「网络请求哪家强」》，所以拿来记录下，学习下。大神勿喷。 HTTP先了解下 HTTP 方便下边的学习。 HTTP 是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。 它是 1990 年被提出来的，经过几年的发展，得到不断的完善和扩展，现在已经使用 HTTP 1.1。 我们把 Http 协议中的通信的两方称作 Client 和 Server (或 Host)，Client 向 Server 端经过 http 协议发送一个 Request，Server 端收到 Request 后经过一系列的处理返回给 Client 一个 Responce。 1、Http 全称：超文本传输协议（HyperText Transfer Protocol） 作用：设计之初是为了将超文本标记语言（HTML）文档从 Web 服务器传送到客户端的浏览器，现在 Http 的作用已经不局限于 HTML 的传输了。 版本：http/1.0 、 http/1.1* 、http/2.0 2、URL scheme ： 指定底层使用的协议（http、https、ftp） host ： HTTP 服务器的 IP 地址或者是域名（www.baidu.com） post ： HTTP 服务器的默认的端口号是 80 ，这种情况下端口号一般是可以省略的。 path ： 访问资源的路径（/js/user） url-params query-string ： 发送给 http 服务器的数据 anchor ：锚 3、Request 和 Responce1、Request 消息结构有三部分： Request line (请求行) 包括 http 请求种类、请求资源的路径、http 协议版本 http header http 的头部信息 body 发送给服务器的 query 信息 当使用的是 GET 请求的时候，body 是空的。 2、Responce 消息结构也有三部分 Request line 协议版本、状态码、message Request header Requset 头信息 body 返回的请求资源主题 4、get 和 post 1、现在主流的网络请求框架有那些？android-async-http (好久已经没有维护了，先不说这个了) Volley是 2013 年 Google I/O 大会上推出的网络请求框架，支持 HttpClient、HttpUrlConnection，甚至支持 OkHttp。也封装了 ImageLoader。但是不支持post大数据，所以不适合上传文件。据说 Volley 的设计初衷本身是为频繁的、数据量较小的网络请求而生的。 OkHttphttps://github.com/square/okhttp是 Square 公司开源的针对 Java 和 Android 程序，封装的一个高性能 http 请求库，所以它的职责跟 HttpUrlConnection是一样的，支持 spdy、http 2.0、websocket ，支持同步、异步，而且 OkHttp 又封装了线程池，封装了数据转换，封装了参数使用、错误处理等，api 使用起来更加方便。可以把它理解成是一个封装之后的类似 HttpUrlConnection 的一个东西，但是你在使用的时候仍然需要自己再做一层封装，这样才能像使用一个框架一样更加顺手。 Retrofithttps://github.com/square/retrofit是 Square 公司出品的默认基于OkHttp封装的一套 RESTful 网络请求框架，不了解 RESTful 概念的不妨去搜索学习下，RESTful 可以说是目前流行的一套 api 设计的风格，并不是标准。Retrofit 的封装可以说是很强大，里面涉及到一堆的设计模式，你可以通过注解直接配置请求，你可以使用不同的 http 客户端，虽然默认是用 http ，可以使用不同 Json Converter 来序列化数据，同时提供对 RxJava 的支持，使用 Retrofit + OkHttp + RxJava + Dagger2 可以说是目前比较潮的一套框架，但是需要有比较高的门槛。 2、OkHttp 的使用1、概述 get 请求 post 请求 上传文件 下载文件 加载图片 支持请求回调，直接返回对象、对象集合 支持 session 的保持 添加依赖 compile &apos;com.squareup.okhttp3:okhttp:3.6.0&apos; 2、使用方法1、get 请求 1.1 get 请求数据 //1、创建OkHttpClient对象 OkHttpClient mOkHttpClient = new OkHttpClient(); //2、创建Request Request request = new Request .Builder() .url(&quot;https://www.baidu.com/&quot;) .build(); //3，将Request封装成Call Call call = okHttpClient.newCall(request); //4，执行call方法,异步执行 call.enqueue(new Callback() { //请求失败 @Override public void onFailure(Call call, IOException e) { } //请求成功 @Override public void onResponse(Call call, Response response) throws IOException { //注意这里是string()，而不是toString,注意 final String str = response.body().string(); //注意：这里还是子线程，要是刷新Ui的话，请使用runOnUiThread() runOnUiThread(new Runnable() { @Override public void run() { mTv.setText(str); } }); } }); 1.2 get 请求下载文件 OkHttpClient mOkHttpClient = new OkHttpClient(); Request request = new Request.Builder() .get() .url(&quot;http://192.xxx.1.138:8080/a.jpg&quot;) .build(); Call call = okHttpClient.newCall(request); call.enqueue(new Callback() { @Override public void onFailure(Call call, IOException e) { } @Override public void onResponse(Call call, Response response) throws IOException { InputStream is = response.body().byteStream(); File file = new File(Environment.getExternalStorageDirectory(),&quot;xm.jpg&quot;); FileOutputStream fos = new FileOutputStream(file); int len = 0; byte[] buf = new byte[1024]; while((len= is.read(buf))!= -1){ fos.write(buf,0,len); } fos.flush(); fos.close(); is.close(); Log.e(TAG,&quot;success&quot;); } }); 2、post 请求 2.1 post 方式提交 Json OkHttpClient mOkHttpClient = new OkHttpClient(); //创建json JSONObject jsonObj = new JSONObject(); try{ jsonObj.put(&quot;username&quot;,username); jsonObj.put(&quot;password&quot;,password); }catch(JSONException e){ e.printStackTrace(); } String jsonParams = jsonObj.toString(); Request request = new Request.Builder() .url(mBaseUrl + &quot;postString&quot;)//注意这里的url .post(RequestBody.create(MediaType.parse(&quot;application/json; charset=utf-8&quot;),jsonParams)) .build(); Call call = okHttpClient.newCall(request); call.enqueue(new Callback() { //请求失败 @Override public void onFailure(Call call, IOException e) { } //请求成功 @Override public void onResponse(Call call, Response response) throws IOException { }); 2.2 post 方法提交表单 和 &lt;form&gt; 标签相同效果， 键值对。 OkHttpClient mOkHttpClient = new OkHttpClient(); RequestBody formBody = new FormBody.Builder() .add(&quot;username&quot;, &quot;xm&quot;) .add(&quot;password&quot;, &quot;123&quot;) .build(); Request request = new Request.Builder() .url(mBaseUrl + &quot;login&quot;) .post(formBody) .build(); Call call = okHttpClient.newCall(request); call.enqueue(new Callback() { //请求失败 @Override public void onFailure(Call call, IOException e) { } //请求成功 @Override public void onResponse(Call call, Response response) throws IOException { }); 2.3 post 上传文件 OkHttpClient mOkHttpClient = new OkHttpClient(); File flie = new File(Environment.getExternalStorageDirectory(),&quot;aa.jpg&quot;); if (!flie.exists()){ Toast.makeText(this, flie.getAbsolutePath()+&quot;不存在&quot;, Toast.LENGTH_SHORT).show(); return; } //MediaType mime type //如果不知道类型的话，就写application/octet-stream Request requset = new Request.Builder() .url(mBaseUrl+&quot;postFile&quot;) .post(RequestBody.create(MediaType.parse(&quot;application/octet-stream&quot;),flie)) .build(); Call call = okHttpClient.newCall(request); call.enqueue(new Callback() { //请求失败 @Override public void onFailure(Call call, IOException e) { } //请求成功 @Override public void onResponse(Call call, Response response) throws IOException { }); 3、封装鸿洋大神已经为我们封装了 okhttputils ,那我们就直接拿来用用好了 地址： https://github.com/hongyangAndroid/okhttputils","tags":[{"name":"Android retrofit","slug":"Android-retrofit","permalink":"http://wmding.com/tags/Android-retrofit/"}]},{"title":"Android 图标的使用","date":"2017-03-18T03:15:32.000Z","path":"2017/03/18/Android 图标的使用/","text":"在 Android 中我们使用的图标一般是 .png 。当然也有其他是设置方法。 一、在 Android 中使用 SVG 矢量图Android 5.X 中提供了两个新的 API 来帮助支持 SVG VectorDrawable AnimatedVectorDrawable 什么是 SVGSVG （Scalable Vector Graphics，可伸缩矢量图形）是 W3C 推出的一种开放标准的文本矢量图形描述语言，它是基于 XML 的、专门为网络而设计的图像格式、SVG 是一种采用 XML 来描述二维图形的语言，所以它可以直接打开 xml 文件来修改和编辑 1、矢量图的优点 矢量图是用点和线来描述图形，所以文件会比较小，同时也能提供高清晰的画面 矢量图缩放自由且不会失真，完全适配于任何分辨率的屏幕 矢量图是以 xml 语言来描述的，所以它修改自如 矢量图色彩分辨率非常高清，同时支持滤镜 跨平台，因为矢量图是纯文本格式来描述的，所以不受平台限制 2、SVG 简单使用1、创建 Vector Asset 2、选择自己喜欢的图片进行创建 3、创建完成 4、使用在布局文件中使用同 .png 图片一样，引入即可使用。 二、在 Android 中使用 iconfont 图标阿里巴巴矢量图标库给开发人员带来了很大的福利，程序猿再也不用担心美工不给作图了。 地址： http://www.iconfont.cn/plus 1、简单使用，下载 点击下载，进入下载页面进行下载，可以根据需要设置颜色和下载不同的格式（SVG 、AI 、PNG）。 2、高级用法 从 iconfont 平台上选择要使用的图标，并下载到本地，复制字体文件（iconfont.ttf）到项目 assets 目录中。 打开下载后的文件，并打开 demoXxx.html 文件，找到图标对应的 HTML 实体字符码 打开项目中 res/values/strings.xml 文件，添加 string 值 在布局文件中引入，添加 string 值到 TextView &lt;TextView android:id=&quot;@+id/tv_icon&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/icon_user&quot; android:textSize=&quot;30sp&quot; /&gt; 为 TextView 指定文字，在 MainActivity 文件中添加 Typeface typeface = Typeface.createFromAsset(getAssets(),&quot;iconfont.ttf&quot;); TextView textView = (TextView) findViewById(R.id.tv_icon); TextView textView1 = (TextView) findViewById(R.id.tv_icon_collection); TextView textView2 = (TextView) findViewById(R.id.tv_icon_message); textView.setTypeface(typeface); textView1.setTypeface(typeface); textView2.setTypeface(typeface); 做完这几部就 OK 了。就可以优雅的使用 iconfont 图标了。 三、站在巨人的肩膀上不要重复造轮子，有牛人写了库，我们就直接拿来用就好了。 地址： https://github.com/mikepenz/Android-Iconics","tags":[{"name":"Android","slug":"Android","permalink":"http://wmding.com/tags/Android/"}]},{"title":"Android Toolbar的学习","date":"2017-03-15T15:07:32.000Z","path":"2017/03/15/Android Toolbar的学习/","text":"Android Toolbar在一个小项目中使用到了 Toolbar ，但是怎么都设置不好。出现了一些问题： 每个界面要显示的标题不同，怎样设置标题，并使标题居中显示。 在 Toolbar 的左边添加一个返回的箭头。 带着这些问题，我决定找资料学习下它，方便以后项目中的使用。 下边的学习记录均来自 CSDN 上 亦枫Blog 的文章。Android Toolbar，你想知道的都在这里了 Android 3.0 之后，Google 使用的 ActionBar ，想统一 Android 的导航栏。但是 ActionBar 难以定制，很多开发者就放弃了 ActionBar 的使用，而是使用普通的 ViewGroup 来封装，或者使用 JakeWharton 大神的 ActionBarSherlock 库。 2014 年的 Google I/O 大会上提出 Material Design 。support library 中很快就出来了 Toolbar 控件，一个定制化的 ViewGroup，来完善 ActionBar 的使用。 使用方法1、在 Theme 中隐藏现有的 ActionBar在注册文件中更改样式 android:theme=&quot;@style/Theme.AppCompat.Light.NoActionBar&quot; 2、在布局文件中添加 Toolbar 控件&lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/tb_toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; android:background=&quot;@color/colorPrimary&quot; app:title=&quot;@string/app_name&quot; app:titleTextColor=&quot;@android:color/white&quot;&gt; &lt;/android.support.v7.widget.Toolbar&gt; 3、在 Activity 中使用 Toolbar 对象替换 ActionBarsetSupportActionBar(mToolbar); PS：好像不加这句话也可以。 其他一些属性可以通过 app:xxx 和使用 Java 代码来控制。titleTextAppearance、subtitleTextAppearance 也可以用来控制标题颜色和大小 到这里已经可以显示标题栏了。 4、Options Menu在 menu 资源目录下新建一个 toolbar_menu.xml ，添加 menu 内容 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt; &lt;item android:id=&quot;@+id/action_search&quot; android:icon=&quot;@android:drawable/ic_menu_search&quot; android:title=&quot;search&quot; app:showAsAction=&quot;collapseActionView&quot;/&gt; &lt;/menu&gt; 在 Java 代码中添加为 Toolbar 添加对应的 Menu Item ，并设置点击事件 @Override public boolean onCreateOptionsMenu(Menu menu) { getMenuInflater().inflate(R.menu.search, menu); return super.onCreateOptionsMenu(menu); } @Override public boolean onOptionsItemSelected(MenuItem item) { switch (item.getItemId()) { case R.id.action_search: //TODO search break; } return super.onOptionsItemSelected(item); } 但是此时溢出按钮(就是竖着的3个小点) 是黑色的，要修改成白色，可以通过修改 Toolbar 的 theme 和 popupTheme 属性来改变，在 Toolbar 中添加： &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/tb_toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; android:background=&quot;@color/colorPrimary&quot; app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot; app:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot; app:title=&quot;@string/app_name&quot; app:titleTextColor=&quot;@android:color/white&quot;&gt; &lt;/android.support.v7.widget.Toolbar&gt; 方法二：一般也是采用这种做法，将 Toolbar 相关属性集中写到一个 style 中 &lt;style name=&quot;OverFlowMenuTheme&quot; parent=&quot;Theme.AppCompat.NoActionBar&quot;&gt; &lt;!-- 设置Menu菜单的背景色 --&gt; &lt;item name=&quot;android:itemBackground&quot;&gt;@android:color/white&lt;/item&gt; &lt;!-- 设置Menu菜单的字体颜色 --&gt; &lt;item name=&quot;android:textColorPrimary&quot;&gt;@android:color/black&lt;/item&gt; &lt;!-- 设置Menu窗口不覆盖Toolbar视图 --&gt; &lt;item name=&quot;overlapAnchor&quot;&gt;false&lt;/item&gt; &lt;/style&gt; 然后在布局文件中的 Toolbar 上进行引用 &lt;android.support.v7.widget.Toolbar ... app:theme=&quot;@style/OverFlowMenuTheme&quot; ... &lt;/android.support.v7.widget.Toolbar&gt; 5、Toolbar 上左边的返回在二级菜单等 Activity 中，通过设置来显示 Toolbar 左边显示一个返回按钮 getSupportActionBar().setDisplayHomeAsUpEnabled(true); 现在只是显示了，给它设置监听： 1、方式一：通过 android.R.id.home 监听返回按钮的点击事件，返回上级页面中。 @Override public boolean onOptionsItemSelected(MenuItem item) { switch (item.getItemId()){ case android.R.id.home: finish(); break; } return super.onOptionsItemSelected(item); } 2、方式二：通过给 Toolbar 设置导航图标的点击事件来进行监听 mToolbar.setNavigationOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { finish(); } }); 6、标题居中可以在 Toolbar 里放置一个 TextView 控件作为居中的标题来使用，再将 Toolbar 的标题隐藏来实现标题居中显示。 &lt;android.support.v7.widget.Toolbar xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/tb_toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; app:popupTheme=&quot;@style/OverFlowMenuTheme&quot; app:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot; android:background=&quot;@color/colorPrimary&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot; android:text=&quot;SecondActivity&quot; style=&quot;@style/TextAppearance.AppCompat.Widget.ActionBar.Title&quot;/&gt; &lt;/android.support.v7.widget.Toolbar&gt; 去除 Toolbar 中的标题，在布局文件中使用 app:title=&quot;&quot; 无法隐藏的，需要在代码中隐藏 getSupportActionBar().setDisplayShowTitleEnabled(false); 到这里，Toolbar 就已经搞定了。","tags":[{"name":"Android","slug":"Android","permalink":"http://wmding.com/tags/Android/"}]},{"title":"Activity的生命周期","date":"2017-03-05T10:45:27.000Z","path":"2017/03/05/Activity的生命周期/","text":"每当说到这个话题的时候，我内心是拒绝的。（ps：心想这个有啥说的，就几个生命周期的方法嘛）。 但是好像有人说，活动的生命周期是非常重要的，作为一个Android开发者来说，你很有必要去深入了解活动的生命周期，以便可以写出更加连贯流畅的程序。 同时在面试过程中，也有许多同学每每都遇到这个问题，例如：onStart()和onResume()有什么区别，什么情况下Activity走了onCreat()，但是没有有onStart()…. 看到这里，我感觉，我很有必要去深入了解Activity的生命周期。根据郭霖的第一行代码（第二版）来进行学习。 1、返回栈1、Android中的活动是可以重叠的，也就是我们每启动一个新的活动，就会覆盖在原来的活动上，点击Back键或者调用finish()，就会销毁最上面的活动，下面的活动就会显示出来。那Android是如何实现的呢？那是因为Android中使用任务（Task）来管理活动，一个任务就是一组存放在栈里的活动的集合。这个栈就是返回栈（Back Stack）。 说到栈是不是很熟悉呢？—&gt;先进后出 2、活动状态每一个活动在其生命周期中最多有4个状态 1、运行状态 最不容易被系统回收。 2、暂停状态 当活动不再处于栈顶，但仍然可见时，活动就进入了暂停状态。那这个活动都不在栈顶了，怎么还会可见呢？—&gt;这种情况是因为并不是每一个活动都会沾满整个屏幕，比如对话框的活动只会占用屏幕中间的部分区域，很快就会在后面看到这个活动。后边的那个活动处于暂停状态，仍然是完全存活的。系统也不会去轻易的去回收这个活动。只有在内存极低的情况下，才会回收这个活动。 3、停止状态 当活动不再处于栈顶，同时完全不可见的时候，就进入了停止状态，这时系统仍然会为这个活动保存相应的状态和成员变量，但是并不是完全可靠的，当其他地方需要内存时，处于停止状态的活动有可能会被系统回收。 4、销毁状态 当一个活动从返回栈中移除的时候，就变成了销毁状态。系统更倾向于回收这个状态的活动，来保证手机的内存充足。 3、活动的生命周期Activity中定义了7个回调方法 1、onCteate() 新建一个Activity的时候就默认重写了这个方法。它在Activity第一次创建的时候调用.在这个方法中可以做这些操作：》》完成Activity的初始化（加载布局，绑定事件）。 2、onStart() 在Activity由不可见变为可见的时候调用。 3、onResume() 在Activity准备好和用户交互的时候调用，此时的活动一定是位于返回栈的栈顶，并且是处于运行状态。 4、onPause() 在系统准备去启动或者是准备恢复另一个Activity的时候调用。可以做的操作—&gt;将一些资源释放，保存一些关键数据。但是请注意：：：注意：：：这个方法中的执行速度一定要快，否则会影响到新的栈顶活动的调用。 5、onStop() 在Activity在完全不可见的时候调用。注意：它和onPause()的区别在于：如果启动的新Activity是一个对话框形式的Activity的话，onPause()方法得到调用，但是这个方法不会调用。 6、onDestory() 在Activity被销毁之前调用，之后活动的状态就变成了销毁状态。 7、onRestart() 在Activity由停止状态变为运行状态之前调用，也就是说这个Activity重新启动了。 上个图吧：： 4、活动被回收了怎么办？一个Activity被系统回收以后，要是重新显示的话，就会重新从onCreate()方法开始。但是这样的话就存在一点小的问题：MainActivity中有一个文本的输入框，我们输入了一些文字，然后进入到了新的Activity中，这时MainActivity被系统回收了，当我回到MainActivity中的时候，我发现我输入的文字没有了，这有点DT啊，那应该如何来解决这个问题呢？ Android提供了onSaveInstanceState()方法。 这个方法可以保证Activity在回收前一定被调用，它携带了Bundle类型的参数，用于保存数据。在Activity重新加载的收进行恢复。 如下： //重写了这个方法，把要保存的数据放入 @Override public void onSaveInstanceState(Bundle outState, PersistableBundle outPersistentState) { super.onSaveInstanceState(outState, outPersistentState); String etContent = et.getText().toString(); outState.putString(&quot;etContent&quot;,etContent); } 在onCteate()方法中获取 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); if (savedInstanceState != null){ et.setText(savedInstanceState.getString(&quot;etContent&quot;)); } }","tags":[{"name":"Android","slug":"Android","permalink":"http://wmding.com/tags/Android/"}]},{"title":"颜色的性格","date":"2017-01-14T00:08:42.000Z","path":"2017/01/14/颜色的性格/","text":"一 、常见的APP颜色在调试代码使用颜色的时候，总是不知道什么颜色比较好看，通过看术与道（移动应用UI设计必修课）上有APP图标的８种基本颜色： 天蓝色 #5AC8FA 黄色 #FFCD00 橘黄色 #FF9600 红色 #FF2D55 蓝色 #007AFF 绿色 #4BD964 红色 #FF3B30 灰色 #8E8E93 二、颜色的性格如何搭配才能把APP的颜色搭配的高大上呢，先了解下颜色的性格吧。 1、白色 白色象征纯洁、神圣、善良、信任与开放，但是在应用中白色面积太大的话，会给人疏离、梦幻的感觉。在一些文艺范的应用中会使用白色作为主色，以及配合大量的留白，体现一个格调的感觉。 2、蓝色 蓝色是灵性和知性兼具的色彩，在色彩心理学的测试中发现几乎没有人对蓝色反感。 明亮的天空蓝，象征着希望、理想和独立； 暗沉的蓝，意味着诚实、信赖和权威； 正蓝、宝蓝在热情中带着坚定与智能； 淡蓝、粉蓝可以让自己也让对方完全放松 蓝色无论是在美术设计中，还是在APP设计中，都是使用最广泛的颜色之一。 3、红色 红色象征热情，性感、权威和自信，是一种能量充沛的色彩，这个色彩充满了自信，全然地要别人注意你，不过也会给人血腥、暴力的印象，容易造成心理压力，在一些需要烘托热烈气氛的APP中可以考虑使用红色。 网易云音乐应用界面就是使用的红色。 4、橙色 橙色给人亲切、坦率、开朗和健康的感觉，有阳光一般的热情。橙色的快乐和活力可以很好的表现激情和参与的理念。 芬达的广告就是充满了健康阳光且具有活力。 橙色可以应用在从事社会服务工作等专业类的应用中，另外电商类的应用中也是非常青睐橙色系，希望激发起人们购物欲望。 5、黄色 黄色是明度极高的颜色，能刺激大脑中与焦虑有关的区域，具有警告的效果。艳黄色象征着信心，聪明和希望； 淡黄色显得天真、浪漫和娇嫩 虽然各种黄色色调并不十分有魅力，但其明亮和愉快的特质能向潜在用户传递一些温暖和乐观。黄色是一种非常难于处理的颜色，黄色在明度较低的时候会显得很脏，所以慎用黄色。 糗事百科使用的是黄色。 6、绿色 绿色给人无限的安全感受，象征着自由和平，新鲜和舒适。黄色给人清新、有活力、快乐的感受；明度较低的草绿、墨绿和橄榄绿给人沉稳、知性的印象。所以绿色可以使用在安全杀毒类的APP，也可以使用在环保、健康类的APP中。 360卫士Snap Lock锁屏 7、粉红色 粉红色象征着温柔、甜美、、浪漫以及没有压力，可以软化攻击、安抚浮躁。比较粉红色更深的桃红色则象征着女性化的热情，比起粉红色的浪漫，桃红色更为洒脱、大方的色彩。 所以粉红色一般使用在用户为女性的APP中，由于粉红色也有轻佻的感觉，所以避免使用在需要表示权威和专业的APP中。 蘑菇街 8、黑色 黑色象征权威、高雅、低调和创意，也意味着执着、冷漠和防御。 9、灰色 灰色象征诚恳，沉稳和考究。其中的铁灰，碳灰，暗灰，在无形中散发出智能，成功以及强烈的权威等信息；中灰与淡灰则带有哲学家的沉静，特别受金融业人士喜爱；当我们需要体现智能，成功，权威，诚恳，认真和沉稳等性格的时候，可以使用灰色。 10、紫色 紫色是优雅、浪漫，并且具有哲学家气质的颜色。紫色的光波最短，在自然界张较少见到，所以被引申为象征高贵的色彩。深紫色有高贵、神秘、高不可攀的感觉；而艳紫色则是魅力十足、有点狂野又难以预测的华丽浪漫。紫色不是App经常使用的颜色，但要是使用的话，会显得非常惊艳。 美拍应用、幸福孕妈 11、褐色、棕色、咖啡色系 这个色系典雅中蕴含着安定、沉稳、平和个情切，给人情绪稳定、容易相处的感觉。搭配不好的话，会让人感到沉闷、单调、老气且缺乏活力，当需要表现友善情切时可以使用咖啡色系。","tags":[{"name":"Android","slug":"Android","permalink":"http://wmding.com/tags/Android/"}]},{"title":"Android 6.0运行时权限","date":"2017-01-02T14:00:32.000Z","path":"2017/01/02/Android6.0运行时权限/","text":"新的一年，新的开始。前几天郭大神在CSDN公开课上讲解了Android6.0运行时权限，没有完全搞清楚，今天趁着有时间，就再仔细的学习下。开始2017年的第一篇博客。 1、过去Android权限机制在低于Android6.0的版本中，我们在添加权限的时候只是需要在AndroidManifest.xml的文件中添加权限的声明即可，比如我们要申请打电话的权限： &lt;uses-permission android:name=&quot;android.permission.CALL_PHONE&quot;/&gt; 这样申请完之后，我们就可以使用打电话的权限了。然后这种情况对于用户的隐私得不到保障，而且用户拒绝申请某一项权限的话，就无法安装使用此软件，这样是不是很蛋疼啊，我明明知道这个软件不用获取短信的权限，你还让我授权，我要是不授权，你还不让我使用，这不是很蛋疼吗？？？为了解决这一系列的问题，在Android6.0以后，加入了运行时权限。 2、运行时权限运行时权限就是，用户在安装软件的时候，不需要一次性授权所有申请的权限，而是可以在使用软件的过程中再对某一项权限进行授权。也就是我安装的时候拒绝授权某个权限，我还是可以安装这个软件，还是可以使用这个软件的其他的功能。 现在把Android的所有的权限分为了两类： 普通权限 危险权限 （1）、普通权限也就是那些不会直接威胁到用户的安全和隐私的权限，对于这部分的权限的申请，我们还是直接在AndroidManifest.xml中直接申请就行了，不需要动态的申请权限。比如联网权限。。。 （2）、危险权限这些权限可能会触及到用户的安全和隐私，我们在AndroidManifest.xml中申请后，还需要在代码中动态申请权限。比如获取设备的联系人信息，定位，读写SD卡。。。 Android中危险权限有9组24个 （3）、基本使用@OnClick(R.id.btn_getPermission) public void getPermission() { //判断用户有没有授予权限，如果没有申请的话就申请，申请了的话就执行 if (ContextCompat.checkSelfPermission(this, Manifest.permission.CALL_PHONE) != PackageManager.PERMISSION_GRANTED) { ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.CALL_PHONE}, 1); } else { call(); } } private void call() { //为了解决报红的问题，放在了try catch中 try { Intent intent = new Intent(Intent.ACTION_CALL); intent.setData(Uri.parse(&quot;tel:10086&quot;)); startActivity(intent); }catch (SecurityException e){ e.printStackTrace(); } } //申请权限的回调 @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode) { case 1: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) { //同意申请权限 call(); } else { //拒绝申请权限 Toast.makeText(this, &quot;权限被拒绝了&quot;, Toast.LENGTH_SHORT).show(); } break; default: break; } } 这里是对打电话的权限进行了申请，也是基本的使用方法。 注意：在/storage/emulated/0/Android/data的路径要是不想直接读写SD卡，对权限进行处理的话，可是使用它的一些路径 //得到/storage/emulated/0/Android/data/xm.permissiontest1/cache //也就是得到data文件下本软件包名的cache文件 File file = getExternalCacheDir(); Log.e(TAG, &quot;cache:&quot;+file.toString() ); ///storage/emulated/0/Android/data/xm.permissiontest1/files //这里传空是指根目录 File externalFilesDir = getExternalFilesDir(&quot;&quot;); Log.e(TAG, &quot;file:&quot;+externalFilesDir); ///storage/emulated/0/Android/data/xm.permissiontest1/files/abc File f = getExternalFilesDir(&quot;abc&quot;); Log.e(TAG, &quot;f:&quot;+f); （4）、封装基本的实现已经学习完了，那这只是在一个Activity中实现了，要想在其他的Activity中使用，那岂不是又要重新写一遍了，所以要对它进行封装。写一次，其他的地方都可以使用。 基本思路：在BaseActivity中定义一个方法来写请求申请权限，然后让其他的Activity都继承，那样的话就可以很方便的调用了。 那就来看看是怎么实现的吧！！！ BaseActivity.java public class BaseActivity extends AppCompatActivity { interface PermissionListener{ void onCranted(); void onDenied(List&lt;String&gt; deniedPermission); } private static PermissionListener mListener; public static void requestRuntimePermission(String[] permissions,PermissionListener listener) { //这里是使用Activity的管理类，获取到当前的activity的实例 Activity topActivity = ActivityCollector.getTopActivity(); if (topActivity == null){ return; } mListener = listener; List&lt;String&gt; permissionList = new ArrayList&lt;&gt;(); for (String permission : permissions) { if (ContextCompat.checkSelfPermission(topActivity, permission) != PackageManager.PERMISSION_GRANTED) { permissionList.add(permission); } } if (!permissionList.isEmpty()) { ActivityCompat.requestPermissions(topActivity, permissionList.toArray(new String[permissionList.size()]), 1); } else { mListener.onCranted(); } } @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode) { case 1: if (grantResults.length &gt; 0) { List&lt;String&gt; deniedPermissions = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; grantResults.length; i++) { int grantResult = grantResults[i]; String permission = permissions[i]; if (grantResult != PackageManager.PERMISSION_GRANTED){ deniedPermissions.add(permission); } } if (deniedPermissions.isEmpty()){ mListener.onCranted(); }else { mListener.onDenied(deniedPermissions); } } break; } } } ActivityCollector.java /* 对Activty进行管理 */ public class ActivityCollector { private static List&lt;Activity&gt; activityList = new ArrayList&lt;&gt;(); public static void addActivity(Activity activity) { activityList.add(activity); } public static void removeActivity(Activity activity) { activityList.remove(activity); } /* * 获得当前的Activivy */ public static Activity getTopActivity() { if (activityList.isEmpty()) { return null; } else { return activityList.get(activityList.size() - 1); } } } MainActivity.java @OnClick(R.id.btn_getPermission) public void getPermission() { //注意这里addActivity(); ActivityCollector.addActivity(this); requestRuntimePermission(new String[]{Manifest.permission.CALL_PHONE, Manifest.permission.ACCESS_COARSE_LOCATION}, new PermissionListener() { @Override public void onCranted() { Toast.makeText(MainActivity.this, &quot;所有的权限都同意了&quot;, Toast.LENGTH_SHORT).show(); call(); } @Override public void onDenied(List&lt;String&gt; deniedPermission) { for (String permission : deniedPermission) { Toast.makeText(MainActivity.this, &quot;被拒绝的权限有：&quot; + permission, Toast.LENGTH_SHORT).show(); } } }); } private void call() { //为了解决报红的问题，放在了try catch中 try { Intent intent = new Intent(Intent.ACTION_CALL); intent.setData(Uri.parse(&quot;tel:10086&quot;)); startActivity(intent); } catch (SecurityException e) { e.printStackTrace(); } } 注意，那个Activity的管理类，在实验的时候，怎么搞都没有反应，原来是ActivityCollector中没有addActicity()，所以acticityList为空，直接给return了。","tags":[{"name":"Android","slug":"Android","permalink":"http://wmding.com/tags/Android/"}]},{"title":"总结2016_计划2017","date":"2016-12-31T15:22:42.000Z","path":"2016/12/31/总结2016-计划2017/","text":"又到年末，对自己一年的工作生活进行一个简单的总结，对来年新的生活做一个计划。生活便是这样，总结–&gt;计划—&gt;总结… 总结过去在过去的一年中，结束了大三的学生生活，来到了大学的终点。回想大学生活，时光总是匆匆，留下的、记住的是那么少。 这一年的暑假前，在我周围的同学都考虑是否选择去培训的时候，我就开始去找实习工作，因为我觉得自己对于专业知识虽然不是很精通，但是已经入门，至少比他们会的要多，所以我就没有考虑去培训，在加上培训费用确实很高，所以我就毅然决然的去找实习工作。但是仅仅是去找，然后并没有思考怎样才能找到，没有去想怎样去提升自己的能力，所以自己碰了好多的灰。 暑假中，我真正的认识到了只有自己提升了能力，才有机会，也才有资格去工作。所以我没有再去找实习工作，而是选择了学习。还好有考研的果果陪我一起，经过一个月的闭关磨练，把java和android的基础知识学习了一遍。自我感觉学习的已经差不多了，就决定继续去找工作。 十一前来到北京，开始我的北漂生活。还好一休在这里，果断的投奔了他。 第一份工作 经过一周的找工作，终于找到了一个实习工作，做手机端的开发，只不过是使用js做的。使用的DeviceOne，之前只是了解过ReactNative，虽然学过java对于js不是那么的陌生，但是上手还是有一定的难度，但是通过自己的努力还是在项目中做出了自己的贡献，在那里我认识闰严，学伟，等项目快要上线的时候，boss来找我谈话，意思是项目结束了，我也就可以走了。我日，心中一万个草泥马奔过来。真是日了狗了，就这样，我的第一份实习工作结束了。并在最后结算工资的时候少给了我1k左右。就这样，我没有再去找他理论，只是心中默默的记住，我要提升自己的能力，让自己变得强大。同时他也给我上了一课。 第二份工作 结束第一份工作后，我开始慌了，开始迷茫，不知道该怎样继续北漂的时候，一休跟我说，你这才刚刚开始，没有工作了继续去找啊，至少比你刚来北京更有阅历了啊，其他说的啥，也记不住了，反正那时候是给了我莫大的鼓励。无意中在看简书的时候，发现现在的公司在招android实习生，然后发了一份简历过去。很快帆哥对我进行了电话面试，问了一些基本的知识，也都是我之前就见过的，我便可以很容易的回答出来，然后便在第二天成功的入职。虽然薪资不是太高，可能还不够我在北京的生活，但是我那是的第一个想法就是，先学东西，先提升自己，然后再说其他的。所以我现在就是保持着这样一颗学习的心，在工作中慢慢前进。 2016年马上就要结束，我坚信我经历的都会帮助我成长，就这样痛并快乐着。 展望未来在2017年即将到来的时刻，很有必要给自己定几个小目标。 1、做好毕业设计，顺利毕业。 2、坚持写博客，把自己的个人网站做好。 3、在工作中敢于说出自己的想法，在说之前一定要想明白支撑你想法的观点。对于自己不会的知识，一定要自己想去思考，自己想办法去实现，然后再去跟别人交流。 4、对于新技术的学习中，做到不是仅仅的知道，了解。而是要明白它的原理，在跟别人交流的时候，可以说出自己的看法。 5，在生活中，照顾好自己，好好爱晶姐。 希望2017年可以越来越好。越努力就越幸运，加油！！！","tags":[{"name":"随笔","slug":"随笔","permalink":"http://wmding.com/tags/随笔/"}]},{"title":"Service","date":"2016-12-18T04:07:32.000Z","path":"2016/12/18/Service/","text":"Service是一个专门在后台处理长时间任务的Android四大组件之一，它没有UI。 Service，有几种启动方式？1、两种启动方式startService和bindService 2、两者的区别1、startService只是启动Service，启动它的组件（如Activity）和Service并没有关联。只有当Service调用stopSelf或者其他组件调用stopService的时候才会终止。 2、bindService方法启动Service，其他组件可以通过回调获取Service的代理对象和Service交互，而这两方也进行了绑定，当启动方销毁的时候，Service也会自动进行unBind操作，当发现所有的绑定有进行了unBind的时候才会销毁。 3、注意它的生命周期 4、Service的onCreate回调函数中可以做耗时操作吗？？？肯定不行！！！Service的onCreate是在主线程中的，耗时操作会阻塞UI，所以不能做耗时操作。 那么如果要是做耗时操作应该怎么办呢？1，线程、Handler 2，IntentService(异步处理服务)：IntentService是继承Service并处理异步请求的一个类，在IntentServce中有一个工作线程俩处理耗时操作。 启动IntentService的方式和启动传统Service一样，同时当执行完后，IntentService会自定的停止，不用我们手动去控制。 可以启动IntentService多次，每启动一次就创建一个word thread，但是IntentService的实例始终只有一个。每一个耗时操作会以工作队列的方式在IntentService的onHandleIntent回调方法中执行。并且每次只会执行一个工作线程，执行完一个再执行第二个。 5、小问题场景：如果一个应用要从网络上下载MP3文件，并在Activity上展示进度条，这个Activity要求是可以转屏的。那么在转屏时Actvitiy会重启，如何保证下载的进度条能正确展示进度呢？","tags":[{"name":"Android","slug":"Android","permalink":"http://wmding.com/tags/Android/"}]},{"title":"Activity的启动方式","date":"2016-12-12T15:07:32.000Z","path":"2016/12/12/Activity的启动方式/","text":"Activity的启动方式之所以记录这个是因为之前想起来面试的时候，有被问到这个问题。4种启动方式分别是：standard、singleTop、singleTask和singleInstance。 1、standard标准的启动方式，启动一次即重新创建一个新的活动对象放到栈中，可能会出现的问题，某一个Activity被无限的创建，比如说是帖子的内容，其实只需要一个，然后里边的内容替换即可。 2、singleTop在启动Activity的时候如果发现返回栈顶已经是该Activity的时候，就不会再次创建这个活动，而是调用该Activity的onNewIntent()方法。 3、singleTask如果要启动的Activity在任务栈中已经存在，就不会创建新的activity，而是复用这个已经存在的activity，调用onNewIntent()方法，并且清空这个activity任务栈上面的所有的activity。 4、singleInstance指定为singleInstance的activity会启动一个新的栈来管理这个activity，即不在应用本身的栈中。","tags":[]},{"title":"初识MVP","date":"2016-12-11T14:04:10.000Z","path":"2016/12/11/初识MVP/","text":"一直想写一篇博客来记录自己的学习，但是一直担心自己写的东西太low，不过后来想了下，要想成为一个有为的程序员，总要迈出这一步的，每天记录一点点，加油！在学校的时候最常听说的是MVC，现在公司都在使用MVP，所以今天就记录下MVP模式。 1、什么是MVPMVP：Model-View-Presenter（ps:本来是想百度下资料，好好的解释一番，但是主要是自己记录学习，也就没有必要了） 之前都是使用MVC的模式，这样使得Activity处理的事情很多，造成了Activity很大。为了解耦，就使用MVP的方式。 2、怎么用呢写一个登录的Demo吧，先知道是怎么写的，然后慢慢理解吧！ 1、资源文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:id=&quot;@+id/activity_main&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;zzu.com.mvptest1.MainActivity&quot;&gt; &lt;EditText android:id=&quot;@+id/et_name&quot; android:hint=&quot;请输入账号&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; /&gt; &lt;EditText android:id=&quot;@+id/et_password&quot; android:hint=&quot;请输入密码&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:inputType=&quot;textPassword&quot; /&gt; &lt;Button android:id=&quot;@+id/btn_login&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;登录&quot;/&gt; &lt;/LinearLayout&gt; 布局文件中就包含一个账号的输入框，一个密码的输入框，一个登录按钮 ###2、MainActivity 要是不使用MVP模式的MainActivity一般是这样写的。 public class MainActivity extends AppCompatActivity{ //这里是使用butterknife，省去了findViewById @Bind(R.id.et_name) EditText et_name; @Bind(R.id.et_password) EditText et_password; private LoginPresenter mLoginPresenter; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ButterKnife.bind(this); } //点击登录按钮 @OnClick(R.id.btn_login) public void onLoginClick(){ //登录 LoginEvent(); } // 登录事件封装成一个方法，然后直接调用即可 private void LoginEvent() { String name = et_name.getText().toString(); String password = et_password.getText().toString(); if (name.isEmpty()||password.isEmpty()){ Toast.makeText(this, &quot;账户和密码不能为空&quot;, Toast.LENGTH_SHORT).show(); }else if (name.equals(&quot;xm&quot;)){ if (password.equals(&quot;123&quot;)){ Toast.makeText(this, &quot;恭喜你登录成功&quot;, Toast.LENGTH_SHORT).show(); }else { Toast.makeText(this, &quot;登录失败--》密码错误&quot;, Toast.LENGTH_SHORT).show(); } } } } 这里是把登录事件放在了Activity中了，这里还这是一个点击事件，要是有很多点击事件的话，那Activity就会很大了，也就是既要处理View层，又要处理业务逻辑层，这样Activity是很累的。 也就是因为这样，MVP模式出现了，首先看下使用MVP时候的项目目录 接口文件： public interface IMainView { //如果登录成功的话，管家会拨打这个电话（这个接口） void LoginSuccess(); //如果登录失败的话，管家会拨打这个电话（这个接口），并告诉MainActivity失败的信息 void LoginFailed(String msg); } 然后让MainActivity来实现这个接口 public class MainActivity extends AppCompatActivity implements IMainView{ @Bind(R.id.et_name) EditText et_name; @Bind(R.id.et_password) EditText et_password; private LoginPresenter mLoginPresenter; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ButterKnife.bind(this); //这里是创建一个管家，然后把自己登录成功和登录失败的联系方式给他 //如果登录成功，管家会拨打loginSuccess这个电话 //如果登录失败，管家会拨打logniFailed(String msg)这个电话 mLoginPresenter = new LoginPresenter(this); } @OnClick(R.id.btn_login) public void onLoginClick(){ String name = et_name.getText().toString(); String password = et_password.getText().toString(); //让管家去处理这个点击事件 mLoginPresenter.login(name,password); } @Override public void LoginSuccess() { Toast.makeText(MainActivity.this, &quot;登录成功了&quot;, Toast.LENGTH_SHORT).show(); } @Override public void LoginFailed(String msg) { Toast.makeText(MainActivity.this, &quot;登录失败--》&quot;+msg, Toast.LENGTH_SHORT).show(); } } 也就是说MainActivity中创建了一个管家，然后让管家来处理这个登录事件，那么这个管家是什么定义的呢？ public class LoginPresenter { private IMainView iMainView; public LoginPresenter(IMainView iMainView) { this.iMainView = iMainView; } //登录事件 public void login(String name,String password) { if (name.isEmpty()||password.isEmpty()){ iMainView.LoginFailed(&quot;账号或密码不能为空&quot;); }else if (name.equals(&quot;xm&quot;)){ if (password.equals(&quot;123&quot;)){ iMainView.LoginSuccess(); }else { iMainView.LoginFailed(&quot;密码错误&quot;); } }else{ iMainView.LoginFailed(&quot;账号名错误&quot;); } } } 自己总结下就是先定义了一个接口，让MainActivity实现这个接口，实现里边方法（回调），又增加了一个类（管家类），然后这类中处理逻辑事件，在MainActivity中创建这个类的对象，然后去调用这个类中的方法。（ps:总结的还是不是太好，自己慢慢理解吧！！！） 明天又是新的一周，新的一天，加油吧，骚年！！","tags":[{"name":"Android","slug":"Android","permalink":"http://wmding.com/tags/Android/"}]},{"title":"Hello World","date":"2016-12-04T01:48:44.858Z","path":"2016/12/04/hello-world/","text":"作为一个小白，倒腾了一天，Hello World终于出来了。不错，加油。 记录点滴博客终于搭建好了，开始我的记录，做一个有为程序员，所以要谨记下面的话： 越努力就越幸运 想的多不如做的多 现在不努力以后拿什么娶媳妇 hexo常用命令记录下hexo的一些简单的命令，方便以后使用 hexonpm install hexo -g #安装 npm update hexo -g #升级 hexo init #初始化 命令简写hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章 hexo p == hexo publish hexo g == hexo generate#生成 hexo s == hexo server #启动服务预览 hexo d == hexo deploy#部署，可与hexo g合并为 hexo d -g","tags":[]}]