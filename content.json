[{"title":"Java虚拟机(一)运行时数据区域","date":"2019-05-28T13:13:29.000Z","path":"2019/05/28/Java虚拟机(一)运行时数据区域/","text":"Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存划分成不同的数据区域。各个区域有自己的用途，有自己的创建和销毁的时间，同时也有自己的生命周期。 1、运行时数据区域Java 虚拟机管理的内存包括以下几个运行时数据区域 程序计数器 Java 虚拟机栈 本地方法栈 Java 堆 方法区 运行时常量池 1、程序计数器一块比较小的内存空间，它可以看作是当前程序执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。 每条线程都需要一个独立的程序计数器，各条线程计数器互不影响，独立存储，即该区域为线程私有的区域 如果线程执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果线程执行的是一个 Native 方法，这个计数器值为空（Undefined） 该内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 的区域 2、Java 虚拟机栈线程私有的，它的生命周期和线程相同。 虚拟机栈描述的是 Java 方法执行的内存模型：每个方法在执行的同时，都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 局部变量表存放了编译期可知的各种基本数据类型、对象引用 在该区域中定义了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常；如果虚拟机栈在动态扩展中无法申请到足够的内存，就会抛出 OutOfMemoryError 异常。 3、本地方法栈本地方法栈和虚拟机栈发挥的作用是非常相似的，他们之间的区别是：虚拟机栈为虚拟机执行 Java 方法服务；而本地方法栈是为虚拟机使用到的 Native 方法服务的。 在 Sun HotSpot 虚拟机中直接就把本地方法栈和虚拟机栈合二为一。 本地方法栈中也定义了两种异常：StackOverflowError 和 OutOfMemoryError 异常。 4、Java 堆Java 堆（Java Heap）是 Java 虚拟机所管理的内存中最大的一块。Java 堆是被所有的线程共享的一块内存区域，在虚拟机启动是创建。此区域的唯一目的就是存放对象实例（所有的对象实例以及数组都在堆上分配） Java 堆是垃圾收集器管理的主要区域，所以也被称为”GC堆“ Java 堆可以处于物理上不连续的内存空间中，只需要逻辑上的连续就行。 如果堆中没有内存完成实例分配，并且堆中也无法再扩展时，将会抛出 OutOfMemoryError 异常。 5、方法栈各个线程共享内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据 如果方法区的内存空间不满足内存分配需求时，Java虚拟机会抛出OutOfMemoryError异常。 6、运行时常量池运行时常量池（Runtime Constant Pool）是方法区的一部分。 Class文件不仅包含了类的版本、接口、字段和方法等信息，还包含了常量池，它用来存放编译时期生成的字面量和符号引用，这些内容会在类加载后存放在方法区的运行时常量池中。 运行时常量池可以理解为是类或接口的常量池的运行时表现形式。 当创建类或接口时，如果构造运行时常量池所需的内存超过了方法区所能提供的最大值，Java虚拟机会抛出OutOfMemoryError异常。","tags":[{"name":"Java Java虚拟机","slug":"Java-Java虚拟机","permalink":"http://wmding.com/tags/Java-Java虚拟机/"}]},{"title":"hexo命令笔记","date":"2019-04-09T09:10:17.000Z","path":"2019/04/09/hexo命令笔记/","text":"在使用 hexo 对博客进行维护时，经常会忘记 hexo 的命令，所以在这里记录下 hexo 的常用的命令 1、创建新的文章文件hexo new &quot;新的文章名字&quot; 2、生成网站静态文件到默认的 public 文件夹中hexo g 3、本地发布启动本地服务器，对写好的文章进行浏览，如果出现问题，及时进行修改 hexo s 4、自动生成网站静态文件，并部署到远程仓库中hexo d 5、清除缓存hexo clean","tags":[{"name":"hexo","slug":"hexo","permalink":"http://wmding.com/tags/hexo/"}]},{"title":"Android 上传文件到服务器","date":"2018-12-20T14:00:32.000Z","path":"2018/12/20/Android上传文件到服务器/","text":"Android 上传文件到服务器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241/** * 生成http连接 * * @param method http请求方式 * @return httpURLConnection * @throws IOException 连接生成失败 */ private static HttpURLConnection createConnection(String urlPath, String method) throws IOException &#123; URL url = new URL(urlPath); HttpURLConnection httpURLConnection = (HttpURLConnection) url.openConnection(); httpURLConnection.setRequestMethod(method); httpURLConnection.setRequestProperty(&quot;Charsert&quot;, &quot;UTF-8&quot;); return httpURLConnection; &#125; private void uploadFile(File file, String url) &#123; //边界标识 随机生成 String BOUNDARY = UUID.randomUUID().toString(); String nextLine = &quot;\\r\\n&quot;; String twoHyphens = &quot;--&quot;; StringBuffer returnData = new StringBuffer(); HttpURLConnection connection = null; OutputStream outputStream = null; FileInputStream inputStream = null; try &#123; //获取HTTPURLConnection连接 connection = createConnection(url, &quot;POST&quot;); //运行写入默认为false，置为true connection.setDoOutput(true); //禁用缓存 connection.setUseCaches(false); //设置接收编码 connection.setRequestProperty(&quot;Accept-Charset&quot;, &quot;utf-8&quot;); //开启长连接可以持续传输 connection.setRequestProperty(&quot;Connection&quot;, &quot;keep-alive&quot;); //设置请求参数格式以及boundary分割线 connection.setRequestProperty(&quot;Content-Type&quot;, &quot;multipart/form-data;boundary=&quot; + BOUNDARY); //设置接收返回值的格式 connection.setRequestProperty(&quot;Accept&quot;, &quot;application/json&quot;); //开启连接 connection.connect(); //获取http写入流 outputStream = new DataOutputStream(connection.getOutputStream()); //分隔符头部 String header = twoHyphens + BOUNDARY + nextLine; //获取文件名字带后缀 String fileName = file.getName(); //获取文件名字不带后缀 String fileNameFirst = fileName.substring(0, fileName.lastIndexOf(&quot;.&quot;)); //分隔符参数设置 header += &quot;Content-Disposition: form-data;name=\\&quot;&quot; + fileNameFirst + &quot;\\&quot;;&quot; + &quot;filename=\\&quot;&quot; + fileName + &quot;\\&quot;&quot; + nextLine + nextLine; MyLog.error(&quot;header : &quot; + header); //写入输出流 outputStream.write(header.getBytes()); //读取文件并写入 inputStream = new FileInputStream(file); byte[] bytes = new byte[1024]; int length; while ((length = inputStream.read(bytes)) != -1) &#123; outputStream.write(bytes, 0, length); &#125; //文件写入完成后加回车 outputStream.write(nextLine.getBytes()); //写入结束分隔符 String footer = nextLine + twoHyphens + BOUNDARY + twoHyphens + nextLine; outputStream.write(footer.getBytes()); outputStream.flush(); //文件上传完成 String tempStr; int responseCode = connection.getResponseCode(); if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) &#123; InputStream inputStream1 = connection.getInputStream(); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream1)); while (true) &#123; tempStr = bufferedReader.readLine(); if (tempStr == null) &#123; break; &#125; returnData.append(tempStr); &#125; MyLog.error(&quot;服务器返回：&quot; + returnData); bufferedReader.close(); &#125; mFaceHttpCallback.onCompeleted(responseCode, returnData.toString(), REG_LIVENESS); &#125; catch (IOException e) &#123; MyLog.error(&quot;uploadFile error:&quot; + e.getMessage()); &#125; finally &#123; try &#123; if (outputStream != null) &#123; outputStream.close(); &#125; if (inputStream != null) &#123; inputStream.close(); &#125; if (connection != null) &#123; connection.disconnect(); &#125; &#125; catch (IOException e) &#123; MyLog.error(&quot;uploadFile error:&quot; + e.getMessage()); &#125; &#125; &#125; /** * 上传多个图片 * * @param actionUrl * @param uploadFiles * @return */ public void uploadFiles(String actionUrl, ArrayList&lt;File&gt; uploadFiles) &#123; DataOutputStream ds = null; InputStream inputStream = null; InputStreamReader inputStreamReader = null; BufferedReader reader = null; StringBuffer resultBuffer = new StringBuffer(); String tempLine; //边界标识 随机生成 String BOUNDARY = UUID.randomUUID().toString(); String PREFIX = &quot;--&quot;; String LINE_END = &quot;\\r\\n&quot;; //内容类型 String CONTENT_TYPE = &quot;multipart/form-data&quot;; try &#123; URL httpUrl = new URL(actionUrl); HttpURLConnection conn = (HttpURLConnection) httpUrl.openConnection(); conn.setReadTimeout(5000); conn.setConnectTimeout(5000); conn.setDoInput(true); //允许输入流 conn.setDoOutput(true); //允许输出流 conn.setUseCaches(false); //不允许使用缓存 conn.setRequestMethod(&quot;POST&quot;); //请求方式 conn.setRequestProperty(&quot;Charset&quot;, &quot;UTF-8&quot;); //设置编码 conn.setRequestProperty(&quot;connection&quot;, &quot;keep-alive&quot;); conn.setRequestProperty(&quot;Content-Type&quot;, CONTENT_TYPE + &quot;;boundary=&quot; + BOUNDARY); //设置接收返回值的格式 conn.setRequestProperty(&quot;Accept&quot;, &quot;application/json&quot;); OutputStream outputSteam=conn.getOutputStream(); ds = new DataOutputStream(outputSteam); for (int i = 0; i &lt; uploadFiles.size(); i++) &#123; StringBuffer sb = new StringBuffer(); sb.append(PREFIX); sb.append(BOUNDARY); sb.append(LINE_END); //获取文件名字带后缀 String fileName = uploadFiles.get(i).getName(); //获取文件名字不带后缀 String fileNameFirst = fileName.substring(0, fileName.lastIndexOf(&quot;.&quot;)); sb.append(&quot;Content-Disposition: form-data;name=\\&quot;&quot;).append(fileNameFirst).append(&quot;\\&quot;;&quot;).append(&quot;filename=\\&quot;&quot;).append(fileName).append(&quot;\\&quot;&quot;).append(LINE_END); sb.append(LINE_END); ds.write(sb.toString().getBytes()); InputStream is = new FileInputStream(uploadFiles.get(i)); byte[] bytes = new byte[1024]; int len; while((len=is.read(bytes))!=-1) &#123; ds.write(bytes, 0, len); &#125; ds.write(LINE_END.getBytes()); is.close(); &#125; byte[] end_data = (PREFIX + BOUNDARY + PREFIX + LINE_END).getBytes(); ds.write(end_data); ds.flush(); MyLog.error(&quot;人脸对比服务器返回：&quot; + conn.getResponseCode()); MyLog.error(&quot;人脸对比服务器返回：&quot; + conn.getResponseMessage()); if (conn.getResponseCode() == HttpURLConnection.HTTP_OK) &#123; inputStream = conn.getInputStream(); inputStreamReader = new InputStreamReader(inputStream); reader = new BufferedReader(inputStreamReader); resultBuffer = new StringBuffer(); while ((tempLine = reader.readLine()) != null) &#123; resultBuffer.append(tempLine); resultBuffer.append(&quot;\\n&quot;); &#125; &#125; mFaceHttpCallback.onCompeleted(conn.getResponseCode(), resultBuffer.toString(), REG_VERIFY); &#125; catch (IOException e) &#123; MyLog.error(&quot;uploadFiles error :&quot; + e.getMessage()); &#125; finally &#123; if (ds != null) &#123; try &#123; ds.close(); &#125; catch (IOException e) &#123; MyLog.error(&quot;uploadFiles error :&quot; + e.getMessage()); &#125; &#125; if (reader != null) &#123; try &#123; reader.close(); &#125; catch (IOException e) &#123; MyLog.error(&quot;uploadFiles error :&quot; + e.getMessage()); &#125; &#125; if (inputStreamReader != null) &#123; try &#123; inputStreamReader.close(); &#125; catch (IOException e) &#123; MyLog.error(&quot;uploadFiles error :&quot; + e.getMessage()); &#125; &#125; if (inputStream != null) &#123; try &#123; inputStream.close(); &#125; catch (IOException e) &#123; MyLog.error(&quot;uploadFiles error :&quot; + e.getMessage()); &#125; &#125; &#125; &#125;","tags":[{"name":"Android","slug":"Android","permalink":"http://wmding.com/tags/Android/"}]},{"title":"Android 5.0 新特性","date":"2018-05-31T15:22:42.000Z","path":"2018/05/31/Android 5.0 新特性/","text":"Android 版本在不断的更新，本文记录各版本有什么新的功能、带给用户怎样的新体验。 1、Android 5.0 新特性 Android 5.0 是 Google 2014年发布的 Android 操作系统。 1.1 Material Design 设计风格Material Design 给用户带来纸张化的体验。它借鉴了传统的印刷设计、以及文字版式、网格系统、空间、比例、配色和图像使用等这些基础的平面设计规范。总之我理解它是一种设计思想，为了用户体验更好。 1.2 支持多设备Android 系统可以用到了更多的设备上，例如：手机，平板，笔记本，智能电视，汽车，智能手表等家用电子产品。 1.3 全新的通知中心设计全新风格的通知系统，优先显示对用户来说比较重要的信息，不太紧急的内容隐藏起来，用户向下滑动就可以查看到全部的通知内容。 1.4 支持 64 位 ART 虚拟机提升内部性能，放弃之前一直使用的 Dalvik 虚拟机，改用 ART 虚拟机，实现了真正的跨平台编译。 1.5 Overview，多任务试图窗多任务视图窗，在界面中，每一个 App 都是一个独立的卡片，拥有立体式的层叠效果，用户可以通过滑动来切换 App。 1.6 使用 RecyclerView 替换 ListView 和 GridViewRecyclerView 提供了一种插拔式的体验，它具有更高的解耦、灵活性、更高的效率，通过它提供的 LayoutManager、ItemDecoration、ItemAnimator 等可以更加丰富多彩的效果。 但是在使用时也有一些缺点：设置列表的分割线时需要自定义，列表的点击事件需要自己实现。 1.7 卡片 CardViewCardView 继承自 FrameLayout 类，并且可以设置圆角和阴影，使得控件具有立体性，在它其中，也可以包含其他的布局容器和控件。 1.8 3种 Notification提供了 3 种 通知栏，分别是普通的 Notification、折叠式 Notification、悬挂式 Notification。 1.9 Toolbar 与 Palette相对于 ActionBar ，Toolbar 最明显的是变得很自由，可以随处放置。 Palette 来提取颜色，从而实现主体更够动态适应当前界面的色调，做到整个 App 颜色的基调和谐统一。Android 提供了集中提取色调的种类： Vibrant(充满活力的) Vibrant dark(充满活力的黑) Vibrant light(充满活力的亮) Muted(柔和的) Muted dark(柔和的黑) Muted light(柔和的亮) 在使用的时候需要引入 Palette 的依赖包。","tags":[{"name":"Android","slug":"Android","permalink":"http://wmding.com/tags/Android/"}]},{"title":"git 操作记录","date":"2018-05-22T15:07:00.000Z","path":"2018/05/22/git操作记录/","text":"在公司的实际开发中，我们都在使用各种各样的版本管理工具：git、svn等。熟练的掌握一些命令是一个程序员的必备 ZB 技能。记录这些 git 命令，方便之后 ZB 成功。 常用命令记录1、从远端克隆代码到本地 git clone git@github.com:wmdkanhai/MyBlog.git 2、查看本地修改状态（查看修改了哪些文件） git status 3、对修改的内容进行上传到远端 git pull //每次提交前记得先从远端获取下，避免冲突 git add . //添加所有 git commit -m &quot;这里写的是本次修改内容&quot; git push //提交到远端 git 使用场景修改一个 bug 后合并到远端 1、在本地新建一个分支，在这个分支上做本次修改 git branch 这个分支的名字 //名字一般为本次修改的功能 git checkout 这个分支的名字 //从原来分支切换到新建分支 git branch -a 查看所有分支 2、修改完 bug 后，进行提交 git pull origin master //更新master分支到本地分支（你本地新建的分支） git add . git commit -m &quot;本次修改的说明&quot; git push origin 这个分支的名字 //把本地分支推送到远端 其他关于分支的操作在远端创建test分支，并把master分支上的数据同步到test分支： git push origin master:test 删除本地test分支 git branch -d test 删除远端test分支 git push origin -d test 查看当前分支 git symbolic-ref --short -q HEAD 重置（修改了一些内容后发现修改的不对，想返回原来的版本） git reset --hard 只合并本地提交到其他分支 // 先切换到要提交的分支，然后执行 git cherry-pick d3xejkfdefec","tags":[{"name":"工具使用","slug":"工具使用","permalink":"http://wmding.com/tags/工具使用/"}]},{"title":"大型网站技术架构-核心原理与案例分析读书笔记","date":"2018-05-16T13:47:02.000Z","path":"2018/05/16/大型网站技术架构-核心原理与案例分析读书笔记/","text":"电子商务的市场背后一般都是不堪重负的网站架构，B2C网站每逢促销必宕机。 如何打造一个高可用、高性能、易扩展、可伸缩且安全的网站？ 大型网站软件系统的特点： 高并发、大流量 高可用 海量数据 用户分布广泛，网络情况复杂 安全环境恶劣 需求快速变更，发布频繁 渐进式发展，从小的网站慢慢演变成长 应用服务和数据服务分离 应用服务器需要处理大量的业务逻辑，需要更快更强大的 CPU 数据库服务器需要快速磁盘检索和数据缓存，所以需要更快的硬盘和更大的内存 文件服务器需要存储大量用户上传的文件，所以需要更大的硬盘 使用缓存改善网站性能 数据库压力太大导致访问延迟，进而影响整个网站的性能，所以使用缓存。 缓存 CDN：内容分发网络，部署在距离终端用户最近的网络服务商，用户的网络请求总是先到达他的网络服务商那里，在这里缓存网站的一些静态资源（较少变化的数据），可以就近以最快速度返回给用户，如视频网站和门户网站会将用户访问大量的热点内容缓存在 CDN。 反向代理：反向代理数据网络前端架构的一部分，部署在网站的前端，当用户请求到达网站的数据中心时，最先访问到的就是反向代理服务器，这里缓存网站的静态资源，无需将请求继续转发给应用服务器就能返回给用户。 本地缓存：在应用服务器本地缓存着热点数据，应用程序可以在本机内存中直接访问数据，而无需访问数据库。 分布式缓存：大型网站的数据量非常庞大，即使只缓存一小部分，需要的内存空间也不是单机能承受的，所以除了本地缓存，还需要分布式缓存，将数据缓存在一个专门的分布式缓存集群中，应用程序可以通过网络通信访问缓存数据。","tags":[{"name":"读书","slug":"读书","permalink":"http://wmding.com/tags/读书/"}]},{"title":"RectF","date":"2018-05-16T13:47:02.000Z","path":"2018/05/16/RectF/","text":"一、Canvas类android.graphics.Canvasgraphics:绘图 Canvas类好比手机中的画纸，我们可以在Canvas上画图形或者图像。一般我们用android来绘画的时候，需要四个组成部分： 1、位图：包含像素 2、Canvas画板：包含绘画内容，写入位图 3、初始图形：如Rect、Bitmap、text等 4、Paint：用来描述上面初始图形的颜色和类型等 Canvas类提供了三个构造方法： Public Canvas（）；构造一个默认无参的Canvas对象 Public Canvas（Bitmap bitmap）；根据一个Bitmap构造一个Canvas对象 Public Canvas（GL gl）；根据一个GL来构造一个对象 下面我们来了解一下Canvas类提供的方法： 在Canvas类提供的方法中比较多经常用的是以draw开头的方法，draw开头的方法很容易理解就是向画板中画图形，比如可以向Canvas中画位图，给图形填充颜色等。 二、Paint类android.graphics.PaintPaint类包含有用来画几何图形、文本、位图的类型和颜色等信息，如果把Canvas类看作是画板，那我们可以把Paint类看做是画笔，可以根据需要画出不同颜色和样式的图形、文本等内容。 Paint类有三个构造方法： Public Paint()构造一个缺省的Paint对象 Public Paint(int flags);根据指定的flags来构造一个Paint对象，创建之后可以用 setFlags（）方法来更改 Public Paint(Paint paint)根据指定的paint对象来构造一个Paint对象 Paint类提供了很多方法来设置和获取Paint对象的属性，比如： public int getColor ()获得Paint对象的颜色值 public ColorFilter getColorFilter ()获得颜色过滤器 public float getTextSize ()获得字体大小数值 public void setStyle (Paint.Style style)设置paint的类型 三 Color类android.graphics.Color此类 定义了一些方法来创建和转换颜色值。 颜色被表示为封装的数值，这个数值由四个字节组成，分别是：alpha、red、green、blue， 这些值是非自 左乘的，也就是说任何透明性只存储在alpha部分，而不是在颜色组成部分。 每一部分按照如下的顺序保存：（alpha&lt;&lt;24）| (red&lt;&lt;16)|&lt;green&lt;&lt;8)|blue.每一部分的取值范围在0-255之间，0意味着这部分不起作 用，255表示100%的起作用。因此不透明的黑色应该是0xFF000000,不透明的白色应该是0xFFFFFFFF 。 Color类提供了12个常量值来代表不同的颜色值，我们在开发工程中可以直接调用这些常量值来设置我们所要修饰的文本、图形等对象。 Color类提供了一个无参的构造方法Color() Color类提供了一些方法来进行颜色值的创建和转换如下： 其中三个方法是用来返回一个颜色常量值的红绿蓝分色，数值分别在0-255之间，如下： Public static red(int color); Public static green(int color); Public static blue(int color); 其中 Public static int rgb(int red,int green,int blue);输入红绿蓝三色，返回一个RGB颜色值。 下面几个方法大家可以参考Android API来了解： Public static int HSVToColor(int alpha,float[] hsv); Public static int HSVToColor(float[] hsv); Public static void RGBToHSV(int red,int green,int blue,float[] hsv); Public static int alpha(int color); Public static int argb(int alpha,int red,int green,int blue); Public static colorToHSV(int color,float[] hsv); Public static parseColor(String colorString); 四．Typeface类android.graphics.TypefaceTypeface：字体 Typeface类定义字体和字体内在的类型。这个类被用在画笔Paint设置的时候，比如用textSize,textSkewX和textScale设置来指定text在画的时候如何来显示和测量。 Typeface 提供了一些常量值来表示自身的一些属性，比如BOLD，BOLD_ITALIC，ITALIC等，开发者可以用 defaultFrOPhone SDNtyle(int style)获得内在的Typeface对象。读者可以参考详细的API文档再这里就不再赘述了。 下面我们来看一下Typeface的主要方法。 Typeface类没有构造方法，通常如果一个类没有构造函数就无法通过构造来生成一个对象实体，此时一般会有特定的静态方法来取得这个类的实体。Typeface就提供了四个静态方法间接来得到Typeface实体分别如下： Public static Typeface create（Typeface family，int style）； 此方法返回一个与已经存在的Typeface字形体系相匹配且类型是指定类型的Typeface。如果你想得到一个与已经存在的Typeface字形体系 相类似，但是样式不一样的Typeface时可以调用此方法。其中family参数可以为null，如果为空则表示从默认的Typeface字形体系中选择。 Public static Typefaxe create(String familyname,int style); 此方法通过给定的字形体系的名称familyname和指定的类型返回一个Typeface对象。如果给定字形体系的名称为null，我们可以通过getStyle（）方法来获得返回Typeface对象的真正的属性。 Public static Typeface createFromAsset(AssetManager mgr,String path); 此方法通过规定的字体数据来返回一个Typeface对象。第一个参数为资源管理器，第二个参数是指定字体类型。 Public static Typeface defaultFrOPhone SDNtyle(int style); 此方法返回一个指定类型的Typeface对象 Typeface还提供了另外三个方法： Public int getStyle();此方法返回Typeface内在的类型属性 Public final Boolean isBold();如果getStyle（）有BOLD位组将返回true Public final Boolean isItalic();如果getStyle（）有ITALIC位组将返回true 五、Path类android.graphics.PathPath类（一组区域）的描画，类囊括多种几何图形比如直线线段、二次曲线、三次曲线等， 调用Canvas.drawPath()方法可以将Path以所定义的paint的方式来画到画板上或者填出图形，也可以用paint所指定方式来画图形。 六、RectF类android.graphics.RectF和Rect类android.graphics.RectRectF 这个类包含一个矩形的四个单精度浮点坐标。 矩形通过上下左右4个边的坐标来表示一个矩形。这些坐标值属性可以被直接访问，用width（）和 height（）方法可以获取矩形的宽和高。注意：大多数方法不会检查这些坐标分类是否错误（也就是left&lt;=right和top&lt;=bottom）. RectF一共有四个构造方法： RectF（）构造一个无参的矩形 RectF（float left,float top,float right,float bottom）构造一个指定了4个参数的矩形 RectF(Rect F r)根据指定的RectF对象来构造一个RectF对象(对象的左边坐标不变) RectF(Rect r)根据给定的Rect对象来构造一个RectF对象 RectF提供了很多方法，下面介绍几个方法： Public Boolean contain(RectF r); 判断一个矩形是否在此矩形内，如果在这个矩形内或者和这个矩形等价则返回true， 同样类似的方法还有public Boolean contain(float left,float top,float right,float bottom)和public Boolean contain(float x,float y)。 Public void union(float x,float y)更新这个矩形，使它包含矩形自己和（x，y）这个点。 RectF类提供的方法都比较简单，容易理解，再此就不再一一赘述 Android.graphics.Rect类，这个类同android.graphics.RectF很相似，不同的地方是Rect类的坐标是用整形表示的，而RectF的坐标是用单精度浮点型表示的。这里大家一定要注意啊。 七、Point类android.graphics.Point这个类从字面意思就可以看出它跟点有关系，是点的一个对象类。 这个类有两个属性，分别是：X坐标和y坐标。 构造函数有三个：Point（），Point（int x，int y），Point（Point p） 主要方法有： Public void set（x，y）；重新设定一下x，y的坐标 Public final void offset(int dx,int dy);给坐标一个补偿值，值可以使正的也可以是负的。 Public final void negate();否定坐标值。 Point类和android.graphics.PointF类似，不同点是前者坐标值的类型是int型，而后者的坐标值是float型。除此之外PointF类多加了几个方法，比如： Public final float length();返回（0，0）点到该点的距离。 Public static float length(float x,float y);返回（0，0）点到（x，y）点的距离。 参数left FLOAT 矩形左下点的 x 坐标。默认值为 0.f。 top FLOAT矩形左下角的 y 坐标。默认值为 0.f。 right FLOAT矩形右下点的 x 坐标。默认值为 0.f。 bottom FLOAT矩形右上角 y 坐标。默认值为 0.f。","tags":[{"name":"Java","slug":"Java","permalink":"http://wmding.com/tags/Java/"}]},{"title":"动画","date":"2018-05-16T13:47:02.000Z","path":"2018/05/16/动画/","text":"View 动画、帧动画、属性动画 View 动画通过对场景里的对象不断的做图像变换(平移，缩放，旋转，透明度)而产生的动画效果，是一种渐进式动画，支持自定义 帧动画是通过顺序播放一系列图像从而产生动画效果，即图片切换动画。 属性动画就是通过动态地改变对象的属性从而达到动画效果 1、View 动画1、View 动画的种类View 动画支持四种动画效果：平移、缩放、旋转、透明度。对应着 Animation 的四个子类 TranslateAnimation、ScaleAnimation、RotateAnimation、AlphaAnimation 这四种动画既可以通过 XML 来定义，也可以通过代码来定义，建议采用 XML 来定义。 实现方式： 1、配置文件 /res/anim alpha scale translate rotate 2、Java 代码实现 AlphaAnitmation ScaleAnimation TranslateAnimation RotateAnimation eg: Animation alpha = new AlphaAnimation() 传统动画(Animation)是系统不断调用onDraw方法重绘界面以实现动画效果，不适合做交互动画效果，只适用于做显示动画； 而属性动画(Animator)则是操作一个get、set方法去真实的改变一个属性。 2、自定义 View 动画继承 Animation 这个抽象类，重写它的 initialize 和 applyTransformation 方法，在 initialize 方法中做一些初始化工作，然后在 applyTransformation 中进行相应的矩阵变化即可。 3、帧动画顺序播放一组预先定义好的图片，类似于电影播放 2、View 动画的特殊使用场景View 动画还可以在一些特殊场景下使用，比如在 ViewGroup 中可以控制子元素的出场效果，在 Activity 中可以实现不同 Activity 之间的切换效果。 1、LayoutAnimation作用于 ViewGroup，为 ViewGroup 指定一个动画，这样当它的子元素出场时都会具有这样动画效果， 这种效果常常被用在 ListView 上，我们时常会看到一种特殊的 ListView ，它的每个 Item 都以一定的动画的形式出现，它使用的就是 LayoutAnimation 1、定义 LayoutAnimation 2、为子元素指定具体的入场动画 3、为 ViewGroup 指定 android：layoutAnimation 属性 2、Activity 的切换效果 1、属性动画属性动画中最简单最常用的就是ObjectAnimator","tags":[{"name":"Android","slug":"Android","permalink":"http://wmding.com/tags/Android/"}]},{"title":"Python 入门","date":"2018-05-16T13:47:02.000Z","path":"2018/05/16/python/","text":"pythonA Byte of Python 新人入门 python，看到有人推荐这本书，便拿来看看，拿到手后发现是英文，这给我出来不少的难题啊，只能找一本中文版来学习，先过一遍，然后中文，英文两个版本一起对照着看下。 2、python 介绍简单易学，功能强大，解释性，面向对象，可扩展性，可嵌入性，丰富的库 3、安装具体安装步骤，找度娘。 //查看是否安装 python -V 4、最初的步骤python//进入python的运行环境 print(&apos;hello world&apos;) 如何推出解释器提示符 Linux 系统中： Ctrl-d Windows 系统中 Ctrl-z 再按 Enter 选择一个编辑器，我目前使用的是 Geany 5、基础5.1、数python 中数的类型有3种：整数、浮点数和复数 整数： 2 浮点数：3.23、5.12、52.3E-4(52.3*10的负4次方) 复数：(-5+4j)、(2.3-4.6j) 注：不区分 long int 。这里默认的整数类型可以是任意长的 5.2、字符串字符串是字符的序列 5.3、单引号，双引号单引号和双引号的使用是完全一样的。 5.4、三引号可以在三引号中自由的使用单引号和双引号 &apos;&apos;&apos;This is a multi-linestring.This is the first line. This is the second line. &quot;What&apos;s your name?,&quot;Iasked. He said&quot;Bond,James Bond.&quot; &apos;&apos;&apos; 5.5、转义序列使用符号：\\ 新的一行：\\n Tab键：\\t 另外在字符串中，一行的末尾的反斜杠表示下一行的字符串是上一行的继续。 &quot;This is the first sentenc\\ This is the second sentence.&quot; 5.6、自然字符串指定一些不被特殊处理，例如转义序列。可以在字符串前附加 r 或 R 来指定自然字符串 5.7、字符串是不可变的5.8、format 方法&gt;&gt;&gt; age = 25 &gt;&gt;&gt; name = &apos;xiaoming&apos; &gt;&gt;&gt; print(&apos;{0} is {1} years old&apos;.format(name,age)) xiaoming is 25 years old 一个字符串能使用确定的格式，然后可以调用 format 方法来代替这些格式，参数要与 format 方法的参数保存一致。 5.9、变量5.10、数据类型5.11、对象Python 是完全面向对象的。 5.12、物理行和逻辑行python中不适用； 每个物理行只写一句逻辑行，当逻辑行太长的时候，使用 \\ 进行连接两个物理行的同一个逻辑行。 5.13、缩进在python 中使用缩进来决定逻辑行缩进的层次 使用缩进来代表代码块，不再使用括号 6、操作符好表达式7、控制流 if for while 7.1、if 语句：number = 23; guess = int(input(&apos;请输入你要猜的数字：&apos;)) if guess == number: print(&apos;正确&apos;) elif guess &lt; number: print(&apos;猜小了&apos;) else: print(&apos;猜大了&apos;) 注意这里的格式。 7.2、while 语句//猜数字游戏，只要用户输入不正确就一直输入 number = 23 running = True while running: guess = int(input(&apos;请输入你要猜的数字：&apos;)) if guess == number: print(&apos;正确&apos;) running = False elif guess &lt; number: print(&apos;猜小了&apos;) else: print(&apos;猜大了&apos;) 7.3、for 循环for..in 是另一个循环语句 for i in range (1,5,2): print(i) # range(1,5) 给出序列[1,2,3,4] # range(1,5,2) 中第三个参数是指步长 7.4、breakbreak 语句是用来终止循环语句的 7.5、continuecontinue 语句是用来跳过当前循环块中的剩余语句，然后继续进行下一轮循环。 8、函数使用关键字 def 来定义 def sayHello(): print(&apos;hello world&apos;) 8.1、函数的参数def printMax(a,b): if a &gt; b: print(a,&apos;is max&apos;) elif a == b: print(a, &apos;is equal to&apos;,b) else: print(b,&apos;is max&apos;) 8.2、在函数中改变一个局部变量的值x = 50 def printNum(): global x ##在函数中改变函数外的值 print(&apos;x is&apos;,x) x=2 print(&apos;changed global x to&apos;,x) printNum() 8.3、默认参数值def fun(x,y=10): return x*y print(fun(2))###20 print(fun(2,20))###40 注意：只有在形参末尾的那些参数可以有默认参数值 8.2、return携带返回值","tags":[{"name":"Python","slug":"Python","permalink":"http://wmding.com/tags/Python/"}]},{"title":"书单","date":"2018-05-16T13:47:02.000Z","path":"2018/05/16/书单/","text":"1、大型网站技术架构：核心原理与案例分析 2、分布式服务框架原理与实践 3、互联网创业核心技术：构建可伸缩的web应用 4、高扩展性网站的50条原则 5、Java性能优化权威指南 6、架构探险：从零开始写Java Web框架 7、架构探险：从零开始写分布式服务框架 8、软件架构师的12项修炼 Java 《深入浅出 Java》 《Think in Java （Java 编程思想）》 《第一行代码（第二版）》 《Android 群英传》 《Android 开发艺术探索》 《Android 设计模式源码分析》 《Android 开发精要》","tags":[{"name":"读书","slug":"读书","permalink":"http://wmding.com/tags/读书/"}]},{"title":"侧滑控件","date":"2018-05-16T13:47:02.000Z","path":"2018/05/16/侧滑控件/","text":"DrawerLayout 1、以 android.suport.v4.widget.DrawerLayout 为根控件 2、DrawerLayout 下包裹两个控件，分别是内容控件和侧滑控件，使用 start 和 end 来区分从哪边滑出。（android:layout_gravity=”start”） 3、设置侧滑事件：mDrawerLayout.setDrawerListener(DrawerLayout.DrawerListener) 给侧滑页面添加内容 NavigationView NavigationView 的使用 1、app:headerLayout=”@layout/header_layout” 表示引入一个头布局文件 2、app:menu=”@menu/main” 表示引入一个 menu 作为下面的点击项 3、获取头部 View headerView = navigationView.getHeaderView(0); 4、item 点击navigationView.setNavigationItemSelectedListener() 添加 ToolBar 1、添加 mToolBar.inflateMenu(R.menu.toolbar_menu); 2、和侧滑栏进行关联 ActionBarDrawerToggle drawerToggle = new ActionBarDrawerToggle(this,mDrawerLayout,mToolBar,R.string.open,R.string.close); drawerToggle.syncState(); mDrawerLayout.addDrawerListener(drawerToggle); TabLayout + ViewPager + Fragment 可滑动顶部菜单","tags":[{"name":"Android","slug":"Android","permalink":"http://wmding.com/tags/Android/"}]},{"title":"Spring 注解","date":"2018-05-16T13:47:02.000Z","path":"2018/05/16/Spring常用注解/","text":"常用 Spring 注解@Component、@Repository、@Service、@Controller、@Resource、@Autowired、@Qualifier 这些都是项目上常用的注解，这些注解的使用大大简化 xml 文件的配置。 这些注解应该如何使用呢？ @Component、@Repository、@Service、@Controller 注解都用于 Bean 的注册. @Resource、@Autowired、@Qualifier 注解用于 Bean 的注入。 1、用于 Bean 注册的注解@Component、@Repository（最早引入的）、@Service、@Controller ，这几个注解都可用于 Bean 的注册，并且作用完全相同，区别仅仅是语义上的区别，分别用在 web 应用的不同层次上： @Repository 用于数据库访问 @Service 用于业务逻辑层 Bean 的注册 @Controller 用于控制层 Bean 的注册 @Component 用于无法明确归类的 Bean 的注册 注意在使用这些注解的同时，需要在 xml 文件中进行配置，指定扫描的内容 &lt;context:component-scan base-package=&quot;com.diit.common.data&quot; &gt;&lt;/context:component-scan&gt; 这样只有 base-package 下的带有注解的类会被注册到 Spring 的容器管理。 Bean 注入@Resource、@Autowired、@Qualifier 这几个注解用于 Bean 注入，它们的区别是： @Resource 默认按照名称装配注入，当不存在名称匹配的 Bean 时会按照类型注入。 @Autowired 默认按照类型装配注入，如果需要名称注入需要使用 @Qualifier 来指定名称。 参考文档Spring注解 @Component @Repository @ Service @Controller 以及 @Resource @Autowired @Qualifier 注入的区别 新引入的注解","tags":[{"name":"Java","slug":"Java","permalink":"http://wmding.com/tags/Java/"}]},{"title":"设计模式之单例模式","date":"2017-05-17T00:49:19.000Z","path":"2017/05/17/设计模式之单例模式/","text":"设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件人员所采用。 总之设计模式给我的印象是很难懂的，但是在后来的实际开发中不断的使用到了设计模式，在面试的过程中也有被问到，所以总结整理下。 1、什么是单例模式单例模式（Single Pattern）属于是创建型模式，提供了一种创建对象的最佳方式。 1、特点： 单例类只能有一个实例 单例类必须自己创建自己的唯一实例 单例类必须给所有其他对象提供这一实例 2、使用场景单例模式确保某个类只有一个实例，而且自己在类的内部实现实例化并向整个系统提供这个实例。 1、要创建的对象需要消耗的资源过多（I/O操作，数据库的连接等）。 2、小光开店中 日报表格只有一份—单例模式这个例子更加生动形象。 3、在 Android 开发中 Application 的创建。内容来自这里 Application和Activity,Service一样是Android框架的一个系统组件，当Android程序启动时系统会创建一个Application对象且只创建一个，用来存储系统的一些信息，所以Application是单例（singleton）模式的一个类。 2、如何使用单例模式1、饿汉式它基于 classloder 机制避免了多线程的问题，所以就线程安全，但是实例在类加载的时候就实例化，浪费内存。 代码示例： /** * 这种实现是饿汉式 * instance 在类加载的时候就实例化，容易产生垃圾对象 */ public class Singleton { //创建 Singleton 的一个对象 private static Singleton instance = new Singleton(); //让构造函数为 private，这样该类就不能被实例化了 private Singleton() { } //获取唯一可用的对象 public static Singleton getInstance(){ return instance; } public void showMessage(){ System.out.println(&quot;hello world ,Singleton Pattern&quot;); } } 其他类调用： public class Client { public static void main(String[] args) { //获取唯一一个可用对象 Singleton instance = Singleton.getInstance(); //调用这个对象的方法 instance.showMessage(); } } 2、懒汉式这种方式是最基本的实现方式，是 Lazy 初始化（懒加载），但是实现最大的问题就是不支持多线程，但是可以通过 synchronized 加锁，达到线程安全。 public class Singleton2 { //先不创建实例，在第一调用getInstance() 时实例化自己 private static Singleton2 instance; private Singleton2() { } public static synchronized Singleton2 getInstance(){ if(instance == null){ instance = new Singleton2(); } return instance; } } 这里使用 synchronized 关键字来锁住 getInstance()，也就是说 getInstance() 方法只能运行在一个线程中，也就是这段代码已经在一个线程中运行，另外一个线程要想运行这块代码就会被阻塞而一直等待。 每次访问都要进行线程同步（调用 synchronized 锁），实际在第一次调用该方法的时候才需要同步，一旦这个实例创建后同步就完全没有必要，所以这种每次都需要同步的方法显然会造成不必要的同步开销。 3、双检锁/双重校验锁（DCL，即 double-checked locking）为了解决上面提到的 每次访问都要进行线程同步 的问题，那加一个条件把它限制在 只在第一调用的时候同步。也就是我们先判断是否创建了实例，实例要是没有存在就进入 进行线程同步，然后创建实例，如果实例已经创建，就直接return。 public class Singleton3 { private volatile static Singleton3 instance = null; private Singleton3(){} public static Singleton3 getIntence(){ if (instance == null) {//先检查实例是否存在 synchronized (Singleton3.class) {//同步代码块，线程安全的创建实例 if (instance == null) {//再次检查，实例不存在就创建实例 instance = new Singleton3(); } } } return instance; } } 这里的 volatile 关键字，作用就是避免 DCL 失效， volatile变量的读操作的性能消耗与普通变量没什么区别；但是写操作可能会变的慢一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。 4、静态内部类 这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。 public class Singleton4 { private Singleton4(){} //静态内部类，该类的实例与外部类的实例没有绑定关系，而且只有被调用的时候 //才会装载，从而实现了延迟加载 private static class SingletonHolder{ //静态初始化器，由JVM来保证线程安全 private static Singleton4 instance = new Singleton4(); } public static Singleton4 getInstance(){ return SingletonHolder.instance; } } 当getInstance()方法第一次被调用的时候，它第一次读取SingletonHolder.instance，导致SingletonHolder类得到初始化；而这个类在装载并被初始化的时候，会初始化它的静态域，从而创建Singleton的实例，由于是静态的域，因此只会在虚拟机装载类的时候初始化一次，并由虚拟机来保证它的线程安全性。 5、枚举 这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。 3、哪些源码中使用到了单例模式","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://wmding.com/tags/设计模式/"}]},{"title":"数据结构与算法","date":"2017-05-17T00:49:19.000Z","path":"2017/05/17/数据结构和算法/","text":"数据结构与算法 数组 链表 双向链表 栈 队列 优先队列 动态编程 字符串操作 二叉树 二叉搜索树 排序算法 哈希表与哈希图 广度优先搜索 深度优先搜索 贪心算法","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://wmding.com/tags/设计模式/"}]},{"title":"Hello World","date":"2017-05-16T16:04:44.000Z","path":"2017/05/17/hello-world/","text":"作为一个小白，倒腾了一天，Hello World终于出来了。不错，加油。 记录点滴博客终于搭建好了，开始我的记录，做一个有为程序员，所以要谨记下面的话： 越努力就越幸运 想的多不如做的多 现在不努力以后拿什么娶媳妇 hexo常用命令记录下hexo的一些简单的命令，方便以后使用 hexonpm install hexo -g #安装 npm update hexo -g #升级 hexo init #初始化 命令简写hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章 hexo p == hexo publish hexo g == hexo generate#生成 hexo s == hexo server #启动服务预览 hexo d == hexo deploy#部署，可与hexo g合并为 hexo d -g","tags":[]},{"title":"AndroidStudio快捷键和插件","date":"2017-05-16T15:51:23.000Z","path":"2017/05/16/AndroidStudio快捷键和插件/","text":"在使用 Android Studio 的过程中，不免使用快捷键来提高逼格，此外还有许多插件帮助我们快速的开发。所以这里做出总结。 1、Android Studio中的常用快捷键1、全局搜索按两次 Shift 2、查找Ctrl + F 3、查找下一处F3 4、查找上一处Shift + F3 5、替换Ctrl + R 6、查找 ClassCtrl + N 7、查找文件Ctrl + Shift + N 8、全局搜索（在文件路径中查找）Ctrl + Shift + F 9、打开文件切换Alt + Right/Left 10、调到源码F4 11、跳转到某行Ctrl + G 12、打开类型层级（查看继承关系）Ctrl + H 13、查看方法层级Ctrl + Shift + H 14、方法调用层级Ctrl + Alt + H （光标放在方法上） 15、重写方法Ctrl + O （Override） 16、实现方法Ctrl + I （实现接口中的方法） 17、快速生成代码块Ctrl + Alt + T 18、提取方法Ctrl + Alt + M 19、大小写切换Ctrl+Shift+U 2、好用的插件1、通过 Wifi 调试手机ADB WiFi 2、ButterKnife 注解生成器：ButterKnife Zelezny 3、把 json 快速转换成 JavaBeanGsonFormat 未完待续，欢迎拍砖。","tags":[{"name":"Android快捷键","slug":"Android快捷键","permalink":"http://wmding.com/tags/Android快捷键/"}]},{"title":"Android 学习笔记目录","date":"2017-05-15T15:49:11.000Z","path":"2017/05/15/Android学习笔记目录/","text":"一直在学习 Android ，但是在使用的时候总是有点不熟悉，趁着毕业前的这段时间，以《Android 开发艺术探索》和《第一行代码（第二版）》为辅助学习的资料，对 Android 的知识进行学习。 在整理的过程中不免会参考和引用别人的文章，我会注明出处，如有问题请联系我，我定会及时改正。 首先对自己认为重要的知识进行挑选 1、Android Studio 快捷键的整理以及好用插件的使用 2、项目构建 Gradle 的学习 3、Activity 的学习 3.1 Activity 的生命周期和启动模式 3.2 Activity 中使用 Menu 3.3 Activity 中 Intent 的使用，特别是 Intent 传递对象 3.4 Activity 的最佳实践（主要包括随时随地退出程序和在实际项目中的写法） 4、View 的学习 4.1 View 的事件体系，滑动冲突的解决 4.2 View 的工作原理 4.3 自定义 View 的分类以及实现方式 5 Fragment 的使用 6 Android 中的数据持久化 6.1 文件存储 6.2 SharedPreferences 存储 6.3 SQLite 数据库存储和操作数据库的一些第三方库 7 网络技术 7.1 主流网络框架的学习 7.2 json 数据的解析 7.3 webView 的使用 8 多媒体 8.1 通知的使用以及底层实现 (RemoteViews) 8.2 拍照，录音，视频 9 Android 动画（view 动画和属性动画） 10 Window 和 WindowManager 11 Material Design 的学习","tags":[{"name":"Android","slug":"Android","permalink":"http://wmding.com/tags/Android/"}]},{"title":"Android 学习笔记目录","date":"2017-05-15T15:49:11.000Z","path":"2017/05/15/Android学习笔记/","text":"一直在学习 Android ，但是在使用的时候总是有点不熟悉，趁着毕业前的这段时间，以《Android 开发艺术探索》和《第一行代码（第二版）》为辅助学习的资料，对 Android 的知识进行学习。 在整理的过程中不免会参考和引用别人的文章，我会注明出处，如有问题请联系我，我定会及时改正。 首先对自己认为重要的知识进行挑选 1、Android Studio 快捷键的整理以及好用插件的使用 2、项目构建 Gradle 的学习 3、Activity 的学习 3.1 Activity 的生命周期和启动模式 3.2 Activity 中使用 Menu 3.3 Activity 中 Intent 的使用，特别是 Intent 传递对象 3.4 Activity 的最佳实践（主要包括随时随地退出程序和在实际项目中的写法） 4、View 的学习 4.1 View 的事件体系，滑动冲突的解决 4.2 View 的工作原理 4.3 自定义 View 的分类以及实现方式 5 Fragment 的使用 6 Android 中的数据持久化 6.1 文件存储 6.2 SharedPreferences 存储 6.3 SQLite 数据库存储和操作数据库的一些第三方库 7 网络技术 7.1 主流网络框架的学习 7.2 json 数据的解析 7.3 webView 的使用 8 多媒体 8.1 通知的使用以及底层实现 (RemoteViews) 8.2 拍照，录音，视频 9 Android 动画（view 动画和属性动画） 10 Window 和 WindowManager 11 Material Design 的学习","tags":[{"name":"Android","slug":"Android","permalink":"http://wmding.com/tags/Android/"}]},{"title":"Glide的基本使用","date":"2017-03-21T00:49:19.000Z","path":"2017/03/21/Glide的基本使用/","text":"现在比较流行、好用的图片加载的框架应该是 Clide 和 Picasso 了。大多数情况下加载图片都是一行代码就能搞定，在平时的项目中也基本就是用用，没有深入的了解。今天看到郭霖大神的微信公共号推送的文章是 《开始新的系列，Glide 的基本使用》，看来郭神是要开始研究 Glide 了。随便拿文章来学习，记录一下，方便以后的使用。 1、开始Glide 是一款由 Bump Technologies 开发的图片加载框架，使得我们可以在 Android 平台上以极度简单的方式加载和展示图片。 Github 上的地址： https://github.com/bumptech/glide 添加依赖： compile &apos;com.github.bumptech.glide:glide:3.7.0&apos; 添加网络权限 &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt; 2、加载图片String url = &quot;http://cn.bing.com/az/hprichbg/rb/Dongdaemun_ZH-CN10736487148_1920x1080.jpg&quot;; //加载图片 Glide.with(this).load(url).into(mImageView); 1、Glide.with() 方法用于创建一个加载图片的实例。with() 方法中可以接收 Context、Activity、Fragment 类型的参数，即不管在 Activity 还是在 Fragment 中调用 with()方法，都可以直接传入 this。要是不在 Activity 中也不在 Fragment 中的话，我们可以获取当前程序的 ApplicationContext 。 注意： with() 中传入的实例会决定 Glide 加载图片的生命周期。 传入的是 Activity 或者 Fragment 的实例，当这个 Activity 或 Fragment 被销毁的收，图片也会停止加载。 传入的是 ApplicationContext ，只有当应用程序被杀掉的时候，图片加载才会停止。 2、load() 方法用于指定加载的图片资源Glide 支持加载各种各样的图片资源，包括网络图片、本地图片、应用资源、二进制流、Uri 对象等等。所以 load() 方法有很多个方法的重载： //加载本地图片 File file = getImagePath(); Glide.with(this).load(file).into(mImageView); // 加载应用资源 int resource = R.drawable.image; Glide.with(this).load(resource).into(imageView); // 加载二进制流 byte[] image = getImageBytes(); Glide.with(this).load(image).into(imageView); // 加载 Uri 对象 Uri imageUri = getImageUri(); Glide.with(this).load(imageUri).into(imageView); 根据自己的情况进行选择 3、into() 方法into() 就是图片在那个 ImageView 上显示。 3、占位图加载图片的时候我们需要等待，这个时间里我们希望优化用户的体验，添加占位图 Glide.with(this) .load(url) .placeholder(R.mipmap.ic_launcher)//添加占位图 .diskCacheStrategy(DiskCacheStrategy.NONE)//禁用 Glide的缓存 .into(mImageView); 由于我们已经加载过图片，所以在测试的时候就没有等到占位图显示出来，我们要加载的图片就已经显示了，这是因为 Glide 有缓存功能，我们把缓存功能去掉，点击加载图片后就可以看到占位图，然后再看到加载的图片了。 4、设置错误图片在加载过程中出错的话，加载出异常占位图，添加 error() Glide.with(this) .load(url) .placeholder(R.mipmap.ic_launcher)//添加占位图 .error(R.drawable.ic_error)//异常占位图 .diskCacheStrategy(DiskCacheStrategy.NONE)//禁用 Glide的缓存 .into(mImageView); 5、设置动画1）、使用 crossFade 来进行设置动画 Glide 默认是包含淡入淡出动画的，时间为 300 ms，我们也可以修改这个时间 Glide.with(this) .load(url) .placeholder(R.mipmap.ic_launcher)//添加占位图 .error(R.drawable.ic_error)//异常占位图 .crossFade(5000)//设置动画时间 .into(mImageView); 2）、使用 dontAnimate 取消动画 Glide.with(this) .load(url) .placeholder(R.mipmap.ic_launcher)//添加占位图 .error(R.drawable.ic_error)//异常占位图 .dontAnimate()//设置取消动画 .into(mImageView); 6、设置加载 Gif在使用 Picasso 是不支持 gif 加载的。但是 Glide 是支持的。 1）、简单的加载 简单的加载 gif 图片和普通图片是一致的。 Glide.with(this) .load(mGifurl)//加载 gif .placeholder(R.mipmap.ic_launcher)//添加占位图 .error(R.drawable.ic_error)//异常占位图 .into(mImageView); 2）、把 gif 图片当作普通图片加载 也就是加载 gif 图片的第一帧，和普通图片一样显示 Glide.with(this) .load(mGifurl)//加载 gif .asBitmap() .placeholder(R.mipmap.ic_launcher)//添加占位图 .error(R.drawable.ic_error)//异常占位图 .into(mImageView); 3）、检查是否是 gif 图片 就是在加载图片的时候判断是否是 gif 图片，如果是就加载，不是就不加载。 Glide.with(this) .load(mGifurl)//加载 gif .asGif()//判断是否是 gif .placeholder(R.mipmap.ic_launcher)//添加占位图 .error(R.drawable.ic_error)//异常占位图 .into(mImageView); 4）、加载本地视频缩略图 这里加载的是本地视频的第一帧，即视频的缩略图 File mVideoFile = new File(Environment.getExternalStorageDirectory(), &quot;xiaoming.mp4&quot;); Glide.with(this) .load(mVideoFile) .placeholder(R.mipmap.ic_launcher)//添加占位图 .error(R.drawable.ic_error)//异常占位图 .into(mImageView);","tags":[{"name":"Android","slug":"Android","permalink":"http://wmding.com/tags/Android/"}]},{"title":"网络请求（二）","date":"2017-03-20T08:15:32.000Z","path":"2017/03/20/网络请求（二）/","text":"retrofit 已经早就听说了，一直没有学习，为了使自己成为一个有理想、有抱负的程序猿，我决定学习下。 本文的学习记录参考 简书上的一篇文章 地址： http://www.jianshu.com/p/19ea72fba61a 1、初识Retrofit 是一个基于 OKHttp 的 Restful API 请求工具。将网络请求变成方法的调用，使用起来非常简洁方便。 官方介绍： http://square.github.io/retrofit/ Retrofit 会将你的 HTTP API 转换为 Java 中 interface 的形式。 通过 new Retrofit.Buidler()….build() 进行 Retrofit 的构建，即使用的是 Builder 模式。 &gt; Builder模式用于将一个复杂的对象的构建和它的表示分离，使得同样的构建过程可以创建不同的表示。这里Retrofit使用Builder模式支持了支持不同的转换（就是将HTTP返回的数据解析成Java对象，主要有Xml、Gson等）和返回（主要作用就是将Call对象转换成另一个对象，比如RxJava）。这里也就真正的达到了构建复杂对象和它的部件进行解耦。 使用 create() 方法创建网络请求接口类 GitHubService 的实例，然后在使用该实例的 listRepos() 方法获取到数据。 2、简单使用1、添加网络权限、添加依赖&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; 依赖： compile &apos;com.squareup.retrofit2:retrofit:2.2.0&apos; //如果用到gson解析 需要添加下面的依赖 compile &apos;com.squareup.retrofit2:converter-gson:2.2.0&apos; 2、创建返回数据的实体类 ResponseBean这里的数据是获取微信精选分类，接口是： http://apicloud.mob.com/wx/article/category/query?key=1228b5a794dc8 数据结构如下： 这里创建实体类的时候直接使用 Android studio 的插件 GsonFormat。 public class ResponseBean { /** * msg : success * result : [{&quot;cid&quot;:&quot;1&quot;,&quot;name&quot;:&quot;时尚&quot;},{&quot;cid&quot;:&quot;2&quot;,&quot;name&quot;:&quot;热点&quot;},{&quot;cid&quot;:&quot;3&quot;,&quot;name&quot;:&quot;健康&quot;},{&quot;cid&quot;:&quot;5&quot;,&quot;name&quot;:&quot;百科&quot;},{&quot;cid&quot;:&quot;7&quot;,&quot;name&quot;:&quot;娱乐&quot;},{&quot;cid&quot;:&quot;8&quot;,&quot;name&quot;:&quot;美文&quot;},{&quot;cid&quot;:&quot;9&quot;,&quot;name&quot;:&quot;旅行&quot;},{&quot;cid&quot;:&quot;10&quot;,&quot;name&quot;:&quot;媒体达人&quot;},{&quot;cid&quot;:&quot;11&quot;,&quot;name&quot;:&quot;搞笑&quot;},{&quot;cid&quot;:&quot;12&quot;,&quot;name&quot;:&quot;影视音乐&quot;},{&quot;cid&quot;:&quot;13&quot;,&quot;name&quot;:&quot;互联网&quot;},{&quot;cid&quot;:&quot;14&quot;,&quot;name&quot;:&quot;文史&quot;},{&quot;cid&quot;:&quot;15&quot;,&quot;name&quot;:&quot;金融&quot;},{&quot;cid&quot;:&quot;16&quot;,&quot;name&quot;:&quot;体育&quot;},{&quot;cid&quot;:&quot;17&quot;,&quot;name&quot;:&quot;游戏&quot;},{&quot;cid&quot;:&quot;18&quot;,&quot;name&quot;:&quot;两性&quot;},{&quot;cid&quot;:&quot;19&quot;,&quot;name&quot;:&quot;社交交友&quot;},{&quot;cid&quot;:&quot;20&quot;,&quot;name&quot;:&quot;女人&quot;},{&quot;cid&quot;:&quot;23&quot;,&quot;name&quot;:&quot;购物&quot;},{&quot;cid&quot;:&quot;24&quot;,&quot;name&quot;:&quot;美女&quot;},{&quot;cid&quot;:&quot;25&quot;,&quot;name&quot;:&quot;微信技巧&quot;},{&quot;cid&quot;:&quot;26&quot;,&quot;name&quot;:&quot;星座&quot;},{&quot;cid&quot;:&quot;27&quot;,&quot;name&quot;:&quot;美食&quot;},{&quot;cid&quot;:&quot;28&quot;,&quot;name&quot;:&quot;教育&quot;},{&quot;cid&quot;:&quot;29&quot;,&quot;name&quot;:&quot;职场&quot;},{&quot;cid&quot;:&quot;30&quot;,&quot;name&quot;:&quot;酷品&quot;},{&quot;cid&quot;:&quot;31&quot;,&quot;name&quot;:&quot;母婴&quot;},{&quot;cid&quot;:&quot;32&quot;,&quot;name&quot;:&quot;摄影&quot;},{&quot;cid&quot;:&quot;33&quot;,&quot;name&quot;:&quot;创投&quot;},{&quot;cid&quot;:&quot;34&quot;,&quot;name&quot;:&quot;典藏&quot;},{&quot;cid&quot;:&quot;35&quot;,&quot;name&quot;:&quot;家装&quot;},{&quot;cid&quot;:&quot;36&quot;,&quot;name&quot;:&quot;汽车&quot;},{&quot;cid&quot;:&quot;37&quot;,&quot;name&quot;:&quot;段子&quot;}] * retCode : 200 */ private String msg; private String retCode; private List&lt;ResultBean&gt; result; public String getMsg() { return msg; } public void setMsg(String msg) { this.msg = msg; } public String getRetCode() { return retCode; } public void setRetCode(String retCode) { this.retCode = retCode; } public List&lt;ResultBean&gt; getResult() { return result; } public void setResult(List&lt;ResultBean&gt; result) { this.result = result; } public static class ResultBean { /** * cid : 1 * name : 时尚 */ private String cid; private String name; public String getCid() { return cid; } public void setCid(String cid) { this.cid = cid; } public String getName() { return name; } public void setName(String name) { this.name = name; } } } 3、把 HTTP API 封装成 interfacepublic interface HttpService { //http://apicloud.mob.com/wx/article/category/query?key=1228b5a794dc8 @GET(&quot;category/{name}&quot;) Call&lt;ResponseBean&gt; getWxData(@Path(&quot;name&quot;) String name, @Query(&quot;key&quot;) String key); } 4、在 MainActivity 中private void initData() { String baseUrl = &quot;http://apicloud.mob.com/wx/article/&quot;; Retrofit retrofit = new Retrofit.Builder() .baseUrl(baseUrl) //返回的数据使用Gson解析 .addConverterFactory(GsonConverterFactory.create()) .build(); HttpService httpService = retrofit.create(HttpService.class); Call &lt;ResponseBean&gt; query = httpService.getWxData(&quot;query&quot;, &quot;1228b5a794dc8&quot;); query.enqueue(new Callback&lt;ResponseBean&gt;() { @Override public void onResponse(Call&lt;ResponseBean&gt; call, Response&lt;ResponseBean&gt; response) { List&lt;ResponseBean.ResultBean&gt; resultBeanList = response.body().getResult(); if (resultBeanList != null){ for (ResponseBean.ResultBean result:resultBeanList) { Log.e(&quot;resultBean&quot;, &quot;onResponse: &quot;+result.getCid()+&quot;-&quot;+result.getName() ); } } } @Override public void onFailure(Call&lt;ResponseBean&gt; call, Throwable t) { } }); 运行获取到数据。 3、和 RxJava 的简单结合使用1、添加依赖compile &apos;io.reactivex:rxandroid:1.2.1&apos; compile &apos;io.reactivex:rxjava:1.1.6&apos; compile &apos;com.google.code.gson:gson:2.8.0&apos; compile &apos;com.squareup.retrofit2:retrofit:2.2.0&apos; //如果用到gson解析 需要添加下面的依赖 compile &apos;com.squareup.retrofit2:converter-gson:2.2.0&apos; //Retrofit使用RxJava需要的依赖 compile &apos;com.squareup.retrofit2:adapter-rxjava:2.1.0&apos; 2、修改接口文件public interface HttpService { //http://apicloud.mob.com/wx/article/category/query?key=1228b5a794dc8 @GET(&quot;category/{name}&quot;) //Call&lt;ResponseBean&gt; getWxData(@Path(&quot;name&quot;) String name, @Query(&quot;key&quot;) String key); Observable&lt;ResponseBean&gt; getWxData(@Path(&quot;name&quot;) String name,@Query(&quot;key&quot;) String key); } 3、在 MainActivity 中private void initData() { String baseUrl = &quot;http://apicloud.mob.com/wx/article/&quot;; Retrofit retrofit = new Retrofit.Builder() .baseUrl(baseUrl) //返回的数据使用Gson解析 .addConverterFactory(GsonConverterFactory.create()) //使用RxJava模式 .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) .build(); HttpService httpService = retrofit.create(HttpService.class); Observable&lt;ResponseBean&gt; query = httpService.getWxData(&quot;query&quot;, &quot;1228b5a794dc8&quot;); query.subscribeOn(Schedulers.io())//设置网络请求在子线程中 .observeOn(AndroidSchedulers.mainThread())//回调在主线程中 .subscribe(new Action1&lt;ResponseBean&gt;() { @Override public void call(ResponseBean responseBean) { //请求成功 List&lt;ResponseBean.ResultBean&gt; resultBeanList = responseBean.getResult(); if (resultBeanList != null) { for (ResponseBean.ResultBean result : resultBeanList) { Log.e(&quot;resultBean&quot;, &quot;onResponse: &quot; + result.getCid() + &quot;-&quot; + result.getName()); } } } }, new Action1&lt;Throwable&gt;() { @Override public void call(Throwable throwable) { //请求失败 } }); } 同样获取到数据。","tags":[{"name":"Android retrofit","slug":"Android-retrofit","permalink":"http://wmding.com/tags/Android-retrofit/"}]},{"title":"给博客添加评论功能","date":"2017-03-20T06:07:32.000Z","path":"2017/03/20/博客添加评论功能/","text":"之前使用的是 TKL 的主题，今天在查看 hexo 地址： https://hexo.io/themes/ 的主题的时候，发现了好多好看的主题，折腾的心又开始在跳动，所以就把博客的主题修改成了 yilia 的。 随便把博客的评论功能添加上去。 1、更换主题1、clone 主题文件到 themes 目录下 git clone https://github.com/litten/hexo-theme-yilia.git yilia 2、在 hexo 根目录中的 _config.yml 文件中进行配置，对主题进行更改 theme: yilia 3、在主题文件中的 _config.yml 中进行配置页面 （PS：注意这个目录） 打开这个文件进行设置，作者已经在设置中添加了注释，所以都可以看明白。 4、需要注意的地方 #你的头像url avatar: /image/icon.jpg 这个地址是相对于博客存放的 github 的地址 2、添加评论功能这里我看大家使用的都是 多说 1、申请添加站点 2、在 hexo 根目录中的 _config.yml 文件中进行配置 # 配置多说评论，wmding是我在多说中添加的站点的名称 duoshuo_shortname: wmding 3、在主题文件中的 _config.yml 中进行配置 duoshuo: true","tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://wmding.com/tags/博客搭建/"}]},{"title":"网络请求（一）","date":"2017-03-18T06:13:32.000Z","path":"2017/03/18/网络请求（一）/","text":"在自己写 Demo 的时候，总是想追求完美，想使用一个自己顺手的网络请求框架，但是又不知道从哪里下手，自己真是 too young,too simple。 今天在翻看 stormzhang 的博客的时候，看到了这篇文章《Android开源项目推荐之「网络请求哪家强」》，所以拿来记录下，学习下。大神勿喷。 HTTP先了解下 HTTP 方便下边的学习。 HTTP 是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。 它是 1990 年被提出来的，经过几年的发展，得到不断的完善和扩展，现在已经使用 HTTP 1.1。 我们把 Http 协议中的通信的两方称作 Client 和 Server (或 Host)，Client 向 Server 端经过 http 协议发送一个 Request，Server 端收到 Request 后经过一系列的处理返回给 Client 一个 Responce。 1、Http 全称：超文本传输协议（HyperText Transfer Protocol） 作用：设计之初是为了将超文本标记语言（HTML）文档从 Web 服务器传送到客户端的浏览器，现在 Http 的作用已经不局限于 HTML 的传输了。 版本：http/1.0 、 http/1.1* 、http/2.0 2、URL scheme ： 指定底层使用的协议（http、https、ftp） host ： HTTP 服务器的 IP 地址或者是域名（www.baidu.com） post ： HTTP 服务器的默认的端口号是 80 ，这种情况下端口号一般是可以省略的。 path ： 访问资源的路径（/js/user） url-params query-string ： 发送给 http 服务器的数据 anchor ：锚 3、Request 和 Responce1、Request 消息结构有三部分： Request line (请求行) 包括 http 请求种类、请求资源的路径、http 协议版本 http header http 的头部信息 body 发送给服务器的 query 信息 当使用的是 GET 请求的时候，body 是空的。 2、Responce 消息结构也有三部分 Request line 协议版本、状态码、message Request header Requset 头信息 body 返回的请求资源主题 4、get 和 post 1、现在主流的网络请求框架有那些？android-async-http (好久已经没有维护了，先不说这个了) Volley是 2013 年 Google I/O 大会上推出的网络请求框架，支持 HttpClient、HttpUrlConnection，甚至支持 OkHttp。也封装了 ImageLoader。但是不支持post大数据，所以不适合上传文件。据说 Volley 的设计初衷本身是为频繁的、数据量较小的网络请求而生的。 OkHttphttps://github.com/square/okhttp是 Square 公司开源的针对 Java 和 Android 程序，封装的一个高性能 http 请求库，所以它的职责跟 HttpUrlConnection是一样的，支持 spdy、http 2.0、websocket ，支持同步、异步，而且 OkHttp 又封装了线程池，封装了数据转换，封装了参数使用、错误处理等，api 使用起来更加方便。可以把它理解成是一个封装之后的类似 HttpUrlConnection 的一个东西，但是你在使用的时候仍然需要自己再做一层封装，这样才能像使用一个框架一样更加顺手。 Retrofithttps://github.com/square/retrofit是 Square 公司出品的默认基于OkHttp封装的一套 RESTful 网络请求框架，不了解 RESTful 概念的不妨去搜索学习下，RESTful 可以说是目前流行的一套 api 设计的风格，并不是标准。Retrofit 的封装可以说是很强大，里面涉及到一堆的设计模式，你可以通过注解直接配置请求，你可以使用不同的 http 客户端，虽然默认是用 http ，可以使用不同 Json Converter 来序列化数据，同时提供对 RxJava 的支持，使用 Retrofit + OkHttp + RxJava + Dagger2 可以说是目前比较潮的一套框架，但是需要有比较高的门槛。 2、OkHttp 的使用1、概述 get 请求 post 请求 上传文件 下载文件 加载图片 支持请求回调，直接返回对象、对象集合 支持 session 的保持 添加依赖 compile &apos;com.squareup.okhttp3:okhttp:3.6.0&apos; 2、使用方法1、get 请求 1.1 get 请求数据 //1、创建OkHttpClient对象 OkHttpClient mOkHttpClient = new OkHttpClient(); //2、创建Request Request request = new Request .Builder() .url(&quot;https://www.baidu.com/&quot;) .build(); //3，将Request封装成Call Call call = okHttpClient.newCall(request); //4，执行call方法,异步执行 call.enqueue(new Callback() { //请求失败 @Override public void onFailure(Call call, IOException e) { } //请求成功 @Override public void onResponse(Call call, Response response) throws IOException { //注意这里是string()，而不是toString,注意 final String str = response.body().string(); //注意：这里还是子线程，要是刷新Ui的话，请使用runOnUiThread() runOnUiThread(new Runnable() { @Override public void run() { mTv.setText(str); } }); } }); 1.2 get 请求下载文件 OkHttpClient mOkHttpClient = new OkHttpClient(); Request request = new Request.Builder() .get() .url(&quot;http://192.xxx.1.138:8080/a.jpg&quot;) .build(); Call call = okHttpClient.newCall(request); call.enqueue(new Callback() { @Override public void onFailure(Call call, IOException e) { } @Override public void onResponse(Call call, Response response) throws IOException { InputStream is = response.body().byteStream(); File file = new File(Environment.getExternalStorageDirectory(),&quot;xm.jpg&quot;); FileOutputStream fos = new FileOutputStream(file); int len = 0; byte[] buf = new byte[1024]; while((len= is.read(buf))!= -1){ fos.write(buf,0,len); } fos.flush(); fos.close(); is.close(); Log.e(TAG,&quot;success&quot;); } }); 2、post 请求 2.1 post 方式提交 Json OkHttpClient mOkHttpClient = new OkHttpClient(); //创建json JSONObject jsonObj = new JSONObject(); try{ jsonObj.put(&quot;username&quot;,username); jsonObj.put(&quot;password&quot;,password); }catch(JSONException e){ e.printStackTrace(); } String jsonParams = jsonObj.toString(); Request request = new Request.Builder() .url(mBaseUrl + &quot;postString&quot;)//注意这里的url .post(RequestBody.create(MediaType.parse(&quot;application/json; charset=utf-8&quot;),jsonParams)) .build(); Call call = okHttpClient.newCall(request); call.enqueue(new Callback() { //请求失败 @Override public void onFailure(Call call, IOException e) { } //请求成功 @Override public void onResponse(Call call, Response response) throws IOException { }); 2.2 post 方法提交表单 和 &lt;form&gt; 标签相同效果， 键值对。 OkHttpClient mOkHttpClient = new OkHttpClient(); RequestBody formBody = new FormBody.Builder() .add(&quot;username&quot;, &quot;xm&quot;) .add(&quot;password&quot;, &quot;123&quot;) .build(); Request request = new Request.Builder() .url(mBaseUrl + &quot;login&quot;) .post(formBody) .build(); Call call = okHttpClient.newCall(request); call.enqueue(new Callback() { //请求失败 @Override public void onFailure(Call call, IOException e) { } //请求成功 @Override public void onResponse(Call call, Response response) throws IOException { }); 2.3 post 上传文件 OkHttpClient mOkHttpClient = new OkHttpClient(); File flie = new File(Environment.getExternalStorageDirectory(),&quot;aa.jpg&quot;); if (!flie.exists()){ Toast.makeText(this, flie.getAbsolutePath()+&quot;不存在&quot;, Toast.LENGTH_SHORT).show(); return; } //MediaType mime type //如果不知道类型的话，就写application/octet-stream Request requset = new Request.Builder() .url(mBaseUrl+&quot;postFile&quot;) .post(RequestBody.create(MediaType.parse(&quot;application/octet-stream&quot;),flie)) .build(); Call call = okHttpClient.newCall(request); call.enqueue(new Callback() { //请求失败 @Override public void onFailure(Call call, IOException e) { } //请求成功 @Override public void onResponse(Call call, Response response) throws IOException { }); 3、封装鸿洋大神已经为我们封装了 okhttputils ,那我们就直接拿来用用好了 地址： https://github.com/hongyangAndroid/okhttputils","tags":[{"name":"Android retrofit","slug":"Android-retrofit","permalink":"http://wmding.com/tags/Android-retrofit/"}]},{"title":"Android 图标的使用","date":"2017-03-18T03:15:32.000Z","path":"2017/03/18/Android 图标的使用/","text":"在 Android 中我们使用的图标一般是 .png 。当然也有其他是设置方法。 一、在 Android 中使用 SVG 矢量图Android 5.X 中提供了两个新的 API 来帮助支持 SVG VectorDrawable AnimatedVectorDrawable 什么是 SVGSVG （Scalable Vector Graphics，可伸缩矢量图形）是 W3C 推出的一种开放标准的文本矢量图形描述语言，它是基于 XML 的、专门为网络而设计的图像格式、SVG 是一种采用 XML 来描述二维图形的语言，所以它可以直接打开 xml 文件来修改和编辑 1、矢量图的优点 矢量图是用点和线来描述图形，所以文件会比较小，同时也能提供高清晰的画面 矢量图缩放自由且不会失真，完全适配于任何分辨率的屏幕 矢量图是以 xml 语言来描述的，所以它修改自如 矢量图色彩分辨率非常高清，同时支持滤镜 跨平台，因为矢量图是纯文本格式来描述的，所以不受平台限制 2、SVG 简单使用1、创建 Vector Asset 2、选择自己喜欢的图片进行创建 3、创建完成 4、使用在布局文件中使用同 .png 图片一样，引入即可使用。 二、在 Android 中使用 iconfont 图标阿里巴巴矢量图标库给开发人员带来了很大的福利，程序猿再也不用担心美工不给作图了。 地址： http://www.iconfont.cn/plus 1、简单使用，下载 点击下载，进入下载页面进行下载，可以根据需要设置颜色和下载不同的格式（SVG 、AI 、PNG）。 2、高级用法 从 iconfont 平台上选择要使用的图标，并下载到本地，复制字体文件（iconfont.ttf）到项目 assets 目录中。 打开下载后的文件，并打开 demoXxx.html 文件，找到图标对应的 HTML 实体字符码 打开项目中 res/values/strings.xml 文件，添加 string 值 在布局文件中引入，添加 string 值到 TextView &lt;TextView android:id=&quot;@+id/tv_icon&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/icon_user&quot; android:textSize=&quot;30sp&quot; /&gt; 为 TextView 指定文字，在 MainActivity 文件中添加 Typeface typeface = Typeface.createFromAsset(getAssets(),&quot;iconfont.ttf&quot;); TextView textView = (TextView) findViewById(R.id.tv_icon); TextView textView1 = (TextView) findViewById(R.id.tv_icon_collection); TextView textView2 = (TextView) findViewById(R.id.tv_icon_message); textView.setTypeface(typeface); textView1.setTypeface(typeface); textView2.setTypeface(typeface); 做完这几部就 OK 了。就可以优雅的使用 iconfont 图标了。 三、站在巨人的肩膀上不要重复造轮子，有牛人写了库，我们就直接拿来用就好了。 地址： https://github.com/mikepenz/Android-Iconics","tags":[{"name":"Android","slug":"Android","permalink":"http://wmding.com/tags/Android/"}]},{"title":"Android Toolbar的学习","date":"2017-03-15T15:07:32.000Z","path":"2017/03/15/Android Toolbar的学习/","text":"Android Toolbar在一个小项目中使用到了 Toolbar ，但是怎么都设置不好。出现了一些问题： 每个界面要显示的标题不同，怎样设置标题，并使标题居中显示。 在 Toolbar 的左边添加一个返回的箭头。 带着这些问题，我决定找资料学习下它，方便以后项目中的使用。 下边的学习记录均来自 CSDN 上 亦枫Blog 的文章。Android Toolbar，你想知道的都在这里了 Android 3.0 之后，Google 使用的 ActionBar ，想统一 Android 的导航栏。但是 ActionBar 难以定制，很多开发者就放弃了 ActionBar 的使用，而是使用普通的 ViewGroup 来封装，或者使用 JakeWharton 大神的 ActionBarSherlock 库。 2014 年的 Google I/O 大会上提出 Material Design 。support library 中很快就出来了 Toolbar 控件，一个定制化的 ViewGroup，来完善 ActionBar 的使用。 使用方法1、在 Theme 中隐藏现有的 ActionBar在注册文件中更改样式 android:theme=&quot;@style/Theme.AppCompat.Light.NoActionBar&quot; 2、在布局文件中添加 Toolbar 控件&lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/tb_toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; android:background=&quot;@color/colorPrimary&quot; app:title=&quot;@string/app_name&quot; app:titleTextColor=&quot;@android:color/white&quot;&gt; &lt;/android.support.v7.widget.Toolbar&gt; 3、在 Activity 中使用 Toolbar 对象替换 ActionBarsetSupportActionBar(mToolbar); PS：好像不加这句话也可以。 其他一些属性可以通过 app:xxx 和使用 Java 代码来控制。titleTextAppearance、subtitleTextAppearance 也可以用来控制标题颜色和大小 到这里已经可以显示标题栏了。 4、Options Menu在 menu 资源目录下新建一个 toolbar_menu.xml ，添加 menu 内容 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt; &lt;item android:id=&quot;@+id/action_search&quot; android:icon=&quot;@android:drawable/ic_menu_search&quot; android:title=&quot;search&quot; app:showAsAction=&quot;collapseActionView&quot;/&gt; &lt;/menu&gt; 在 Java 代码中添加为 Toolbar 添加对应的 Menu Item ，并设置点击事件 @Override public boolean onCreateOptionsMenu(Menu menu) { getMenuInflater().inflate(R.menu.search, menu); return super.onCreateOptionsMenu(menu); } @Override public boolean onOptionsItemSelected(MenuItem item) { switch (item.getItemId()) { case R.id.action_search: //TODO search break; } return super.onOptionsItemSelected(item); } 但是此时溢出按钮(就是竖着的3个小点) 是黑色的，要修改成白色，可以通过修改 Toolbar 的 theme 和 popupTheme 属性来改变，在 Toolbar 中添加： &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/tb_toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; android:background=&quot;@color/colorPrimary&quot; app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot; app:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot; app:title=&quot;@string/app_name&quot; app:titleTextColor=&quot;@android:color/white&quot;&gt; &lt;/android.support.v7.widget.Toolbar&gt; 方法二：一般也是采用这种做法，将 Toolbar 相关属性集中写到一个 style 中 &lt;style name=&quot;OverFlowMenuTheme&quot; parent=&quot;Theme.AppCompat.NoActionBar&quot;&gt; &lt;!-- 设置Menu菜单的背景色 --&gt; &lt;item name=&quot;android:itemBackground&quot;&gt;@android:color/white&lt;/item&gt; &lt;!-- 设置Menu菜单的字体颜色 --&gt; &lt;item name=&quot;android:textColorPrimary&quot;&gt;@android:color/black&lt;/item&gt; &lt;!-- 设置Menu窗口不覆盖Toolbar视图 --&gt; &lt;item name=&quot;overlapAnchor&quot;&gt;false&lt;/item&gt; &lt;/style&gt; 然后在布局文件中的 Toolbar 上进行引用 &lt;android.support.v7.widget.Toolbar ... app:theme=&quot;@style/OverFlowMenuTheme&quot; ... &lt;/android.support.v7.widget.Toolbar&gt; 5、Toolbar 上左边的返回在二级菜单等 Activity 中，通过设置来显示 Toolbar 左边显示一个返回按钮 getSupportActionBar().setDisplayHomeAsUpEnabled(true); 现在只是显示了，给它设置监听： 1、方式一：通过 android.R.id.home 监听返回按钮的点击事件，返回上级页面中。 @Override public boolean onOptionsItemSelected(MenuItem item) { switch (item.getItemId()){ case android.R.id.home: finish(); break; } return super.onOptionsItemSelected(item); } 2、方式二：通过给 Toolbar 设置导航图标的点击事件来进行监听 mToolbar.setNavigationOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { finish(); } }); 6、标题居中可以在 Toolbar 里放置一个 TextView 控件作为居中的标题来使用，再将 Toolbar 的标题隐藏来实现标题居中显示。 &lt;android.support.v7.widget.Toolbar xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/tb_toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; app:popupTheme=&quot;@style/OverFlowMenuTheme&quot; app:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot; android:background=&quot;@color/colorPrimary&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot; android:text=&quot;SecondActivity&quot; style=&quot;@style/TextAppearance.AppCompat.Widget.ActionBar.Title&quot;/&gt; &lt;/android.support.v7.widget.Toolbar&gt; 去除 Toolbar 中的标题，在布局文件中使用 app:title=&quot;&quot; 无法隐藏的，需要在代码中隐藏 getSupportActionBar().setDisplayShowTitleEnabled(false); 到这里，Toolbar 就已经搞定了。","tags":[{"name":"Android","slug":"Android","permalink":"http://wmding.com/tags/Android/"}]},{"title":"Activity的生命周期","date":"2017-03-05T10:45:27.000Z","path":"2017/03/05/Activity的生命周期/","text":"每当说到这个话题的时候，我内心是拒绝的。（ps：心想这个有啥说的，就几个生命周期的方法嘛）。 但是好像有人说，活动的生命周期是非常重要的，作为一个Android开发者来说，你很有必要去深入了解活动的生命周期，以便可以写出更加连贯流畅的程序。 同时在面试过程中，也有许多同学每每都遇到这个问题，例如：onStart()和onResume()有什么区别，什么情况下Activity走了onCreat()，但是没有有onStart()…. 看到这里，我感觉，我很有必要去深入了解Activity的生命周期。根据郭霖的第一行代码（第二版）来进行学习。 1、返回栈1、Android中的活动是可以重叠的，也就是我们每启动一个新的活动，就会覆盖在原来的活动上，点击Back键或者调用finish()，就会销毁最上面的活动，下面的活动就会显示出来。那Android是如何实现的呢？那是因为Android中使用任务（Task）来管理活动，一个任务就是一组存放在栈里的活动的集合。这个栈就是返回栈（Back Stack）。 说到栈是不是很熟悉呢？—&gt;先进后出 2、活动状态每一个活动在其生命周期中最多有4个状态 1、运行状态 最不容易被系统回收。 2、暂停状态 当活动不再处于栈顶，但仍然可见时，活动就进入了暂停状态。那这个活动都不在栈顶了，怎么还会可见呢？—&gt;这种情况是因为并不是每一个活动都会沾满整个屏幕，比如对话框的活动只会占用屏幕中间的部分区域，很快就会在后面看到这个活动。后边的那个活动处于暂停状态，仍然是完全存活的。系统也不会去轻易的去回收这个活动。只有在内存极低的情况下，才会回收这个活动。 3、停止状态 当活动不再处于栈顶，同时完全不可见的时候，就进入了停止状态，这时系统仍然会为这个活动保存相应的状态和成员变量，但是并不是完全可靠的，当其他地方需要内存时，处于停止状态的活动有可能会被系统回收。 4、销毁状态 当一个活动从返回栈中移除的时候，就变成了销毁状态。系统更倾向于回收这个状态的活动，来保证手机的内存充足。 3、活动的生命周期Activity中定义了7个回调方法 1、onCteate() 新建一个Activity的时候就默认重写了这个方法。它在Activity第一次创建的时候调用.在这个方法中可以做这些操作：》》完成Activity的初始化（加载布局，绑定事件）。 2、onStart() 在Activity由不可见变为可见的时候调用。 3、onResume() 在Activity准备好和用户交互的时候调用，此时的活动一定是位于返回栈的栈顶，并且是处于运行状态。 4、onPause() 在系统准备去启动或者是准备恢复另一个Activity的时候调用。可以做的操作—&gt;将一些资源释放，保存一些关键数据。但是请注意：：：注意：：：这个方法中的执行速度一定要快，否则会影响到新的栈顶活动的调用。 5、onStop() 在Activity在完全不可见的时候调用。注意：它和onPause()的区别在于：如果启动的新Activity是一个对话框形式的Activity的话，onPause()方法得到调用，但是这个方法不会调用。 6、onDestory() 在Activity被销毁之前调用，之后活动的状态就变成了销毁状态。 7、onRestart() 在Activity由停止状态变为运行状态之前调用，也就是说这个Activity重新启动了。 上个图吧：： 4、活动被回收了怎么办？一个Activity被系统回收以后，要是重新显示的话，就会重新从onCreate()方法开始。但是这样的话就存在一点小的问题：MainActivity中有一个文本的输入框，我们输入了一些文字，然后进入到了新的Activity中，这时MainActivity被系统回收了，当我回到MainActivity中的时候，我发现我输入的文字没有了，这有点DT啊，那应该如何来解决这个问题呢？ Android提供了onSaveInstanceState()方法。 这个方法可以保证Activity在回收前一定被调用，它携带了Bundle类型的参数，用于保存数据。在Activity重新加载的收进行恢复。 如下： //重写了这个方法，把要保存的数据放入 @Override public void onSaveInstanceState(Bundle outState, PersistableBundle outPersistentState) { super.onSaveInstanceState(outState, outPersistentState); String etContent = et.getText().toString(); outState.putString(&quot;etContent&quot;,etContent); } 在onCteate()方法中获取 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); if (savedInstanceState != null){ et.setText(savedInstanceState.getString(&quot;etContent&quot;)); } }","tags":[{"name":"Android","slug":"Android","permalink":"http://wmding.com/tags/Android/"}]},{"title":"颜色的性格","date":"2017-01-14T00:08:42.000Z","path":"2017/01/14/颜色的性格/","text":"一 、常见的APP颜色在调试代码使用颜色的时候，总是不知道什么颜色比较好看，通过看术与道（移动应用UI设计必修课）上有APP图标的８种基本颜色： 天蓝色 #5AC8FA 黄色 #FFCD00 橘黄色 #FF9600 红色 #FF2D55 蓝色 #007AFF 绿色 #4BD964 红色 #FF3B30 灰色 #8E8E93 二、颜色的性格如何搭配才能把APP的颜色搭配的高大上呢，先了解下颜色的性格吧。 1、白色 白色象征纯洁、神圣、善良、信任与开放，但是在应用中白色面积太大的话，会给人疏离、梦幻的感觉。在一些文艺范的应用中会使用白色作为主色，以及配合大量的留白，体现一个格调的感觉。 2、蓝色 蓝色是灵性和知性兼具的色彩，在色彩心理学的测试中发现几乎没有人对蓝色反感。 明亮的天空蓝，象征着希望、理想和独立； 暗沉的蓝，意味着诚实、信赖和权威； 正蓝、宝蓝在热情中带着坚定与智能； 淡蓝、粉蓝可以让自己也让对方完全放松 蓝色无论是在美术设计中，还是在APP设计中，都是使用最广泛的颜色之一。 3、红色 红色象征热情，性感、权威和自信，是一种能量充沛的色彩，这个色彩充满了自信，全然地要别人注意你，不过也会给人血腥、暴力的印象，容易造成心理压力，在一些需要烘托热烈气氛的APP中可以考虑使用红色。 网易云音乐应用界面就是使用的红色。 4、橙色 橙色给人亲切、坦率、开朗和健康的感觉，有阳光一般的热情。橙色的快乐和活力可以很好的表现激情和参与的理念。 芬达的广告就是充满了健康阳光且具有活力。 橙色可以应用在从事社会服务工作等专业类的应用中，另外电商类的应用中也是非常青睐橙色系，希望激发起人们购物欲望。 5、黄色 黄色是明度极高的颜色，能刺激大脑中与焦虑有关的区域，具有警告的效果。艳黄色象征着信心，聪明和希望； 淡黄色显得天真、浪漫和娇嫩 虽然各种黄色色调并不十分有魅力，但其明亮和愉快的特质能向潜在用户传递一些温暖和乐观。黄色是一种非常难于处理的颜色，黄色在明度较低的时候会显得很脏，所以慎用黄色。 糗事百科使用的是黄色。 6、绿色 绿色给人无限的安全感受，象征着自由和平，新鲜和舒适。黄色给人清新、有活力、快乐的感受；明度较低的草绿、墨绿和橄榄绿给人沉稳、知性的印象。所以绿色可以使用在安全杀毒类的APP，也可以使用在环保、健康类的APP中。 360卫士Snap Lock锁屏 7、粉红色 粉红色象征着温柔、甜美、、浪漫以及没有压力，可以软化攻击、安抚浮躁。比较粉红色更深的桃红色则象征着女性化的热情，比起粉红色的浪漫，桃红色更为洒脱、大方的色彩。 所以粉红色一般使用在用户为女性的APP中，由于粉红色也有轻佻的感觉，所以避免使用在需要表示权威和专业的APP中。 蘑菇街 8、黑色 黑色象征权威、高雅、低调和创意，也意味着执着、冷漠和防御。 9、灰色 灰色象征诚恳，沉稳和考究。其中的铁灰，碳灰，暗灰，在无形中散发出智能，成功以及强烈的权威等信息；中灰与淡灰则带有哲学家的沉静，特别受金融业人士喜爱；当我们需要体现智能，成功，权威，诚恳，认真和沉稳等性格的时候，可以使用灰色。 10、紫色 紫色是优雅、浪漫，并且具有哲学家气质的颜色。紫色的光波最短，在自然界张较少见到，所以被引申为象征高贵的色彩。深紫色有高贵、神秘、高不可攀的感觉；而艳紫色则是魅力十足、有点狂野又难以预测的华丽浪漫。紫色不是App经常使用的颜色，但要是使用的话，会显得非常惊艳。 美拍应用、幸福孕妈 11、褐色、棕色、咖啡色系 这个色系典雅中蕴含着安定、沉稳、平和个情切，给人情绪稳定、容易相处的感觉。搭配不好的话，会让人感到沉闷、单调、老气且缺乏活力，当需要表现友善情切时可以使用咖啡色系。","tags":[{"name":"Android","slug":"Android","permalink":"http://wmding.com/tags/Android/"}]},{"title":"Android 6.0运行时权限","date":"2017-01-02T14:00:32.000Z","path":"2017/01/02/Android6.0运行时权限/","text":"新的一年，新的开始。前几天郭大神在CSDN公开课上讲解了Android6.0运行时权限，没有完全搞清楚，今天趁着有时间，就再仔细的学习下。开始2017年的第一篇博客。 1、过去Android权限机制在低于Android6.0的版本中，我们在添加权限的时候只是需要在AndroidManifest.xml的文件中添加权限的声明即可，比如我们要申请打电话的权限： &lt;uses-permission android:name=&quot;android.permission.CALL_PHONE&quot;/&gt; 这样申请完之后，我们就可以使用打电话的权限了。然后这种情况对于用户的隐私得不到保障，而且用户拒绝申请某一项权限的话，就无法安装使用此软件，这样是不是很蛋疼啊，我明明知道这个软件不用获取短信的权限，你还让我授权，我要是不授权，你还不让我使用，这不是很蛋疼吗？？？为了解决这一系列的问题，在Android6.0以后，加入了运行时权限。 2、运行时权限运行时权限就是，用户在安装软件的时候，不需要一次性授权所有申请的权限，而是可以在使用软件的过程中再对某一项权限进行授权。也就是我安装的时候拒绝授权某个权限，我还是可以安装这个软件，还是可以使用这个软件的其他的功能。 现在把Android的所有的权限分为了两类： 普通权限 危险权限 （1）、普通权限也就是那些不会直接威胁到用户的安全和隐私的权限，对于这部分的权限的申请，我们还是直接在AndroidManifest.xml中直接申请就行了，不需要动态的申请权限。比如联网权限。。。 （2）、危险权限这些权限可能会触及到用户的安全和隐私，我们在AndroidManifest.xml中申请后，还需要在代码中动态申请权限。比如获取设备的联系人信息，定位，读写SD卡。。。 Android中危险权限有9组24个 （3）、基本使用@OnClick(R.id.btn_getPermission) public void getPermission() { //判断用户有没有授予权限，如果没有申请的话就申请，申请了的话就执行 if (ContextCompat.checkSelfPermission(this, Manifest.permission.CALL_PHONE) != PackageManager.PERMISSION_GRANTED) { ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.CALL_PHONE}, 1); } else { call(); } } private void call() { //为了解决报红的问题，放在了try catch中 try { Intent intent = new Intent(Intent.ACTION_CALL); intent.setData(Uri.parse(&quot;tel:10086&quot;)); startActivity(intent); }catch (SecurityException e){ e.printStackTrace(); } } //申请权限的回调 @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode) { case 1: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) { //同意申请权限 call(); } else { //拒绝申请权限 Toast.makeText(this, &quot;权限被拒绝了&quot;, Toast.LENGTH_SHORT).show(); } break; default: break; } } 这里是对打电话的权限进行了申请，也是基本的使用方法。 注意：在/storage/emulated/0/Android/data的路径要是不想直接读写SD卡，对权限进行处理的话，可是使用它的一些路径 //得到/storage/emulated/0/Android/data/xm.permissiontest1/cache //也就是得到data文件下本软件包名的cache文件 File file = getExternalCacheDir(); Log.e(TAG, &quot;cache:&quot;+file.toString() ); ///storage/emulated/0/Android/data/xm.permissiontest1/files //这里传空是指根目录 File externalFilesDir = getExternalFilesDir(&quot;&quot;); Log.e(TAG, &quot;file:&quot;+externalFilesDir); ///storage/emulated/0/Android/data/xm.permissiontest1/files/abc File f = getExternalFilesDir(&quot;abc&quot;); Log.e(TAG, &quot;f:&quot;+f); （4）、封装基本的实现已经学习完了，那这只是在一个Activity中实现了，要想在其他的Activity中使用，那岂不是又要重新写一遍了，所以要对它进行封装。写一次，其他的地方都可以使用。 基本思路：在BaseActivity中定义一个方法来写请求申请权限，然后让其他的Activity都继承，那样的话就可以很方便的调用了。 那就来看看是怎么实现的吧！！！ BaseActivity.java public class BaseActivity extends AppCompatActivity { interface PermissionListener{ void onCranted(); void onDenied(List&lt;String&gt; deniedPermission); } private static PermissionListener mListener; public static void requestRuntimePermission(String[] permissions,PermissionListener listener) { //这里是使用Activity的管理类，获取到当前的activity的实例 Activity topActivity = ActivityCollector.getTopActivity(); if (topActivity == null){ return; } mListener = listener; List&lt;String&gt; permissionList = new ArrayList&lt;&gt;(); for (String permission : permissions) { if (ContextCompat.checkSelfPermission(topActivity, permission) != PackageManager.PERMISSION_GRANTED) { permissionList.add(permission); } } if (!permissionList.isEmpty()) { ActivityCompat.requestPermissions(topActivity, permissionList.toArray(new String[permissionList.size()]), 1); } else { mListener.onCranted(); } } @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode) { case 1: if (grantResults.length &gt; 0) { List&lt;String&gt; deniedPermissions = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; grantResults.length; i++) { int grantResult = grantResults[i]; String permission = permissions[i]; if (grantResult != PackageManager.PERMISSION_GRANTED){ deniedPermissions.add(permission); } } if (deniedPermissions.isEmpty()){ mListener.onCranted(); }else { mListener.onDenied(deniedPermissions); } } break; } } } ActivityCollector.java /* 对Activty进行管理 */ public class ActivityCollector { private static List&lt;Activity&gt; activityList = new ArrayList&lt;&gt;(); public static void addActivity(Activity activity) { activityList.add(activity); } public static void removeActivity(Activity activity) { activityList.remove(activity); } /* * 获得当前的Activivy */ public static Activity getTopActivity() { if (activityList.isEmpty()) { return null; } else { return activityList.get(activityList.size() - 1); } } } MainActivity.java @OnClick(R.id.btn_getPermission) public void getPermission() { //注意这里addActivity(); ActivityCollector.addActivity(this); requestRuntimePermission(new String[]{Manifest.permission.CALL_PHONE, Manifest.permission.ACCESS_COARSE_LOCATION}, new PermissionListener() { @Override public void onCranted() { Toast.makeText(MainActivity.this, &quot;所有的权限都同意了&quot;, Toast.LENGTH_SHORT).show(); call(); } @Override public void onDenied(List&lt;String&gt; deniedPermission) { for (String permission : deniedPermission) { Toast.makeText(MainActivity.this, &quot;被拒绝的权限有：&quot; + permission, Toast.LENGTH_SHORT).show(); } } }); } private void call() { //为了解决报红的问题，放在了try catch中 try { Intent intent = new Intent(Intent.ACTION_CALL); intent.setData(Uri.parse(&quot;tel:10086&quot;)); startActivity(intent); } catch (SecurityException e) { e.printStackTrace(); } } 注意，那个Activity的管理类，在实验的时候，怎么搞都没有反应，原来是ActivityCollector中没有addActicity()，所以acticityList为空，直接给return了。","tags":[{"name":"Android","slug":"Android","permalink":"http://wmding.com/tags/Android/"}]},{"title":"总结2016_计划2017","date":"2016-12-31T15:22:42.000Z","path":"2016/12/31/总结2016-计划2017/","text":"又到年末，对自己一年的工作生活进行一个简单的总结，对来年新的生活做一个计划。生活便是这样，总结–&gt;计划—&gt;总结… 总结过去在过去的一年中，结束了大三的学生生活，来到了大学的终点。回想大学生活，时光总是匆匆，留下的、记住的是那么少。 这一年的暑假前，在我周围的同学都考虑是否选择去培训的时候，我就开始去找实习工作，因为我觉得自己对于专业知识虽然不是很精通，但是已经入门，至少比他们会的要多，所以我就没有考虑去培训，在加上培训费用确实很高，所以我就毅然决然的去找实习工作。但是仅仅是去找，然后并没有思考怎样才能找到，没有去想怎样去提升自己的能力，所以自己碰了好多的灰。 暑假中，我真正的认识到了只有自己提升了能力，才有机会，也才有资格去工作。所以我没有再去找实习工作，而是选择了学习。还好有考研的果果陪我一起，经过一个月的闭关磨练，把java和android的基础知识学习了一遍。自我感觉学习的已经差不多了，就决定继续去找工作。 十一前来到北京，开始我的北漂生活。还好一休在这里，果断的投奔了他。 第一份工作 经过一周的找工作，终于找到了一个实习工作，做手机端的开发，只不过是使用js做的。使用的DeviceOne，之前只是了解过ReactNative，虽然学过java对于js不是那么的陌生，但是上手还是有一定的难度，但是通过自己的努力还是在项目中做出了自己的贡献，在那里我认识闰严，学伟，等项目快要上线的时候，boss来找我谈话，意思是项目结束了，我也就可以走了。我日，心中一万个草泥马奔过来。真是日了狗了，就这样，我的第一份实习工作结束了。并在最后结算工资的时候少给了我1k左右。就这样，我没有再去找他理论，只是心中默默的记住，我要提升自己的能力，让自己变得强大。同时他也给我上了一课。 第二份工作 结束第一份工作后，我开始慌了，开始迷茫，不知道该怎样继续北漂的时候，一休跟我说，你这才刚刚开始，没有工作了继续去找啊，至少比你刚来北京更有阅历了啊，其他说的啥，也记不住了，反正那时候是给了我莫大的鼓励。无意中在看简书的时候，发现现在的公司在招android实习生，然后发了一份简历过去。很快帆哥对我进行了电话面试，问了一些基本的知识，也都是我之前就见过的，我便可以很容易的回答出来，然后便在第二天成功的入职。虽然薪资不是太高，可能还不够我在北京的生活，但是我那是的第一个想法就是，先学东西，先提升自己，然后再说其他的。所以我现在就是保持着这样一颗学习的心，在工作中慢慢前进。 2016年马上就要结束，我坚信我经历的都会帮助我成长，就这样痛并快乐着。 展望未来在2017年即将到来的时刻，很有必要给自己定几个小目标。 1、做好毕业设计，顺利毕业。 2、坚持写博客，把自己的个人网站做好。 3、在工作中敢于说出自己的想法，在说之前一定要想明白支撑你想法的观点。对于自己不会的知识，一定要自己想去思考，自己想办法去实现，然后再去跟别人交流。 4、对于新技术的学习中，做到不是仅仅的知道，了解。而是要明白它的原理，在跟别人交流的时候，可以说出自己的看法。 5，在生活中，照顾好自己，好好爱晶姐。 希望2017年可以越来越好。越努力就越幸运，加油！！！","tags":[{"name":"随笔","slug":"随笔","permalink":"http://wmding.com/tags/随笔/"}]},{"title":"Service","date":"2016-12-18T04:07:32.000Z","path":"2016/12/18/Service/","text":"Service是一个专门在后台处理长时间任务的Android四大组件之一，它没有UI。 Service，有几种启动方式？1、两种启动方式startService和bindService 2、两者的区别1、startService只是启动Service，启动它的组件（如Activity）和Service并没有关联。只有当Service调用stopSelf或者其他组件调用stopService的时候才会终止。 2、bindService方法启动Service，其他组件可以通过回调获取Service的代理对象和Service交互，而这两方也进行了绑定，当启动方销毁的时候，Service也会自动进行unBind操作，当发现所有的绑定有进行了unBind的时候才会销毁。 3、注意它的生命周期 4、Service的onCreate回调函数中可以做耗时操作吗？？？肯定不行！！！Service的onCreate是在主线程中的，耗时操作会阻塞UI，所以不能做耗时操作。 那么如果要是做耗时操作应该怎么办呢？1，线程、Handler 2，IntentService(异步处理服务)：IntentService是继承Service并处理异步请求的一个类，在IntentServce中有一个工作线程俩处理耗时操作。 启动IntentService的方式和启动传统Service一样，同时当执行完后，IntentService会自定的停止，不用我们手动去控制。 可以启动IntentService多次，每启动一次就创建一个word thread，但是IntentService的实例始终只有一个。每一个耗时操作会以工作队列的方式在IntentService的onHandleIntent回调方法中执行。并且每次只会执行一个工作线程，执行完一个再执行第二个。 5、小问题场景：如果一个应用要从网络上下载MP3文件，并在Activity上展示进度条，这个Activity要求是可以转屏的。那么在转屏时Actvitiy会重启，如何保证下载的进度条能正确展示进度呢？","tags":[{"name":"Android","slug":"Android","permalink":"http://wmding.com/tags/Android/"}]},{"title":"Activity的启动方式","date":"2016-12-12T15:07:32.000Z","path":"2016/12/12/Activity的启动方式/","text":"Activity的启动方式之所以记录这个是因为之前想起来面试的时候，有被问到这个问题。4种启动方式分别是：standard、singleTop、singleTask和singleInstance。 1、standard标准的启动方式，启动一次即重新创建一个新的活动对象放到栈中，可能会出现的问题，某一个Activity被无限的创建，比如说是帖子的内容，其实只需要一个，然后里边的内容替换即可。 2、singleTop在启动Activity的时候如果发现返回栈顶已经是该Activity的时候，就不会再次创建这个活动，而是调用该Activity的onNewIntent()方法。 3、singleTask如果要启动的Activity在任务栈中已经存在，就不会创建新的activity，而是复用这个已经存在的activity，调用onNewIntent()方法，并且清空这个activity任务栈上面的所有的activity。 4、singleInstance指定为singleInstance的activity会启动一个新的栈来管理这个activity，即不在应用本身的栈中。","tags":[]},{"title":"初识MVP","date":"2016-12-11T14:04:10.000Z","path":"2016/12/11/初识MVP/","text":"一直想写一篇博客来记录自己的学习，但是一直担心自己写的东西太low，不过后来想了下，要想成为一个有为的程序员，总要迈出这一步的，每天记录一点点，加油！在学校的时候最常听说的是MVC，现在公司都在使用MVP，所以今天就记录下MVP模式。 1、什么是MVPMVP：Model-View-Presenter（ps:本来是想百度下资料，好好的解释一番，但是主要是自己记录学习，也就没有必要了） 之前都是使用MVC的模式，这样使得Activity处理的事情很多，造成了Activity很大。为了解耦，就使用MVP的方式。 2、怎么用呢写一个登录的Demo吧，先知道是怎么写的，然后慢慢理解吧！ 1、资源文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:id=&quot;@+id/activity_main&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;zzu.com.mvptest1.MainActivity&quot;&gt; &lt;EditText android:id=&quot;@+id/et_name&quot; android:hint=&quot;请输入账号&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; /&gt; &lt;EditText android:id=&quot;@+id/et_password&quot; android:hint=&quot;请输入密码&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:inputType=&quot;textPassword&quot; /&gt; &lt;Button android:id=&quot;@+id/btn_login&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;登录&quot;/&gt; &lt;/LinearLayout&gt; 布局文件中就包含一个账号的输入框，一个密码的输入框，一个登录按钮 ###2、MainActivity 要是不使用MVP模式的MainActivity一般是这样写的。 public class MainActivity extends AppCompatActivity{ //这里是使用butterknife，省去了findViewById @Bind(R.id.et_name) EditText et_name; @Bind(R.id.et_password) EditText et_password; private LoginPresenter mLoginPresenter; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ButterKnife.bind(this); } //点击登录按钮 @OnClick(R.id.btn_login) public void onLoginClick(){ //登录 LoginEvent(); } // 登录事件封装成一个方法，然后直接调用即可 private void LoginEvent() { String name = et_name.getText().toString(); String password = et_password.getText().toString(); if (name.isEmpty()||password.isEmpty()){ Toast.makeText(this, &quot;账户和密码不能为空&quot;, Toast.LENGTH_SHORT).show(); }else if (name.equals(&quot;xm&quot;)){ if (password.equals(&quot;123&quot;)){ Toast.makeText(this, &quot;恭喜你登录成功&quot;, Toast.LENGTH_SHORT).show(); }else { Toast.makeText(this, &quot;登录失败--》密码错误&quot;, Toast.LENGTH_SHORT).show(); } } } } 这里是把登录事件放在了Activity中了，这里还这是一个点击事件，要是有很多点击事件的话，那Activity就会很大了，也就是既要处理View层，又要处理业务逻辑层，这样Activity是很累的。 也就是因为这样，MVP模式出现了，首先看下使用MVP时候的项目目录 接口文件： public interface IMainView { //如果登录成功的话，管家会拨打这个电话（这个接口） void LoginSuccess(); //如果登录失败的话，管家会拨打这个电话（这个接口），并告诉MainActivity失败的信息 void LoginFailed(String msg); } 然后让MainActivity来实现这个接口 public class MainActivity extends AppCompatActivity implements IMainView{ @Bind(R.id.et_name) EditText et_name; @Bind(R.id.et_password) EditText et_password; private LoginPresenter mLoginPresenter; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ButterKnife.bind(this); //这里是创建一个管家，然后把自己登录成功和登录失败的联系方式给他 //如果登录成功，管家会拨打loginSuccess这个电话 //如果登录失败，管家会拨打logniFailed(String msg)这个电话 mLoginPresenter = new LoginPresenter(this); } @OnClick(R.id.btn_login) public void onLoginClick(){ String name = et_name.getText().toString(); String password = et_password.getText().toString(); //让管家去处理这个点击事件 mLoginPresenter.login(name,password); } @Override public void LoginSuccess() { Toast.makeText(MainActivity.this, &quot;登录成功了&quot;, Toast.LENGTH_SHORT).show(); } @Override public void LoginFailed(String msg) { Toast.makeText(MainActivity.this, &quot;登录失败--》&quot;+msg, Toast.LENGTH_SHORT).show(); } } 也就是说MainActivity中创建了一个管家，然后让管家来处理这个登录事件，那么这个管家是什么定义的呢？ public class LoginPresenter { private IMainView iMainView; public LoginPresenter(IMainView iMainView) { this.iMainView = iMainView; } //登录事件 public void login(String name,String password) { if (name.isEmpty()||password.isEmpty()){ iMainView.LoginFailed(&quot;账号或密码不能为空&quot;); }else if (name.equals(&quot;xm&quot;)){ if (password.equals(&quot;123&quot;)){ iMainView.LoginSuccess(); }else { iMainView.LoginFailed(&quot;密码错误&quot;); } }else{ iMainView.LoginFailed(&quot;账号名错误&quot;); } } } 自己总结下就是先定义了一个接口，让MainActivity实现这个接口，实现里边方法（回调），又增加了一个类（管家类），然后这类中处理逻辑事件，在MainActivity中创建这个类的对象，然后去调用这个类中的方法。（ps:总结的还是不是太好，自己慢慢理解吧！！！） 明天又是新的一周，新的一天，加油吧，骚年！！","tags":[{"name":"Android","slug":"Android","permalink":"http://wmding.com/tags/Android/"}]}]